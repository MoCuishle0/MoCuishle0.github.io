<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mocuishle0.github.io/</id>
    <title>MoCuishle</title>
    <updated>2020-08-13T09:28:51.827Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mocuishle0.github.io/"/>
    <link rel="self" href="https://mocuishle0.github.io/atom.xml"/>
    <subtitle>我拥有的都是侥幸，
我失去的都是人生。</subtitle>
    <logo>https://mocuishle0.github.io/images/avatar.png</logo>
    <icon>https://mocuishle0.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MoCuishle</rights>
    <entry>
        <title type="html"><![CDATA[数据库：规范化]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-gui-fan-hua/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-gui-fan-hua/">
        </link>
        <updated>2020-07-14T02:28:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-范式种类">1. 范式种类：</h2>
<ul>
<li>第一范式（1NF）；</li>
<li>第二范式（2NF）；</li>
<li>第三范式（3NF）；</li>
<li>BC范式（BCNF）；</li>
<li>第四范式（4NF）；</li>
<li>第五范式（5NF）；</li>
</ul>
<h2 id="2-第一范式1nf">2. 第一范式（1NF）：</h2>
<blockquote>
<p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于1NF。</p>
</blockquote>
<h2 id="3-第二范式2nf">3. 第二范式（2NF）：</h2>
<p>如果关系模式R属于1NF，且每一个非主属性都完全函数依赖于R的码，则R属于2NF；</p>
<h2 id="4-第三范式3nf">4. 第三范式（3NF）：</h2>
<p>对于满足第三范式的关系模式R，R的每一个非主属性既不部分函数依赖于候选码也不传递依赖于候选码；（非定义，仅为个人理解）</p>
<h2 id="bc范式">BC范式：</h2>
<p>关系模式R中，如果每个决定因素都包含码，则R属于BC范式。</p>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1594694936100.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：视图]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-shi-tu/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-shi-tu/">
        </link>
        <updated>2020-07-14T01:46:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-视图">1. 视图</h2>
<h3 id="11-视图特点">1.1 视图特点</h3>
<ul>
<li>虚表，是从一个或几个基本表（或视图）导出的表；</li>
<li>只存放视图的定义，不存放视图对应的数据；</li>
<li>基本表改变，从视图中查询的数据也改变；</li>
</ul>
<h3 id="12-定义视图">1.2 定义视图</h3>
<h4 id="121-创建">1.2.1 创建</h4>
<p>CREATE VIEW &lt;视图名&gt;[(&lt;列名&gt;&lt;列名&gt;...)]<br>
AS &lt;子查询&gt;<br>
[WITH CHECK OPTION]；</p>
<p>P.s：</p>
<ul>
<li>WITH CHECK OPTION：对视图进行UPDATE，INSERT和DELETE时候，需要保证更新、插入和删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）；</li>
<li>执行CREATE VIEW语句时，只是将视图定义存入数据字典，并不执行其中的SELECT语句；对视图查询时，按视图定义从基本表中查出数据。</li>
</ul>
<p>【建立计算机系学生视图】<br>
CREATE VIEW CS_Student<br>
AS<br>
SELECT  Sno，Sname，Sage<br>
FROM Student<br>
WHERE Sdept=‘CS’；</p>
<p>【建立计算机系学生视图，并要求对视图进行修改和插入操作是仍保证该视图只有计算机系学生】<br>
CREATE VIEW CS_Student<br>
AS<br>
SELECT  Sno，Sname，Sage<br>
FROM Student<br>
WHERE Sdept=‘CS’<br>
WITH CHECK OPTION；</p>
<h4 id="122-删除">1.2.2 删除</h4>
<p>DROP VIEW &lt;视图名&gt;[CASCADE];</p>
<h3 id="13-查询视图">1.3 查询视图</h3>
<p>类似于基本表</p>
<h3 id="14-更新视图">1.4 更新视图</h3>
<p>类似于基本表</p>
<h3 id="15-视图的作用">1.5 视图的作用</h3>
<ul>
<li>简化用户操作</li>
<li>使用户以多种角度看待同一数据</li>
<li>对机密数据提供安全保护</li>
<li>可以更清晰表达查询</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++：new与malloc]]></title>
        <id>https://mocuishle0.github.io/post/cnew-yu-malloc/</id>
        <link href="https://mocuishle0.github.io/post/cnew-yu-malloc/">
        </link>
        <updated>2020-07-12T02:57:49.000Z</updated>
        <summary type="html"><![CDATA[<p>简单来说，new从自由存储区上分配内存，malloc从堆上分配内存；new/delete会调用构造函数/析构函数对对象进行初始化与销毁；operator new/delete可以进行重载。</p>
]]></summary>
        <content type="html"><![CDATA[<p>简单来说，new从自由存储区上分配内存，malloc从堆上分配内存；new/delete会调用构造函数/析构函数对对象进行初始化与销毁；operator new/delete可以进行重载。</p>
<!-- more -->
<h2 id="1-申请的内存所在位置">1. 申请的内存所在位置</h2>
<blockquote>
<p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。</p>
</blockquote>
<p>自由存储区是C++基于new操作符的一个抽象概念，<strong>凡是通过new操作符进行内存申请，该内存即为自由存储区</strong>。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
<p>自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
<h2 id="2-返回类型安全性">2. 返回类型安全性</h2>
<blockquote>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void*，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
</blockquote>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。</p>
<h2 id="3-内存分配失败时的返回值">3. 内存分配失败时的返回值</h2>
<p>new内存分配失败时，<strong>会抛出bac_alloc异常</strong>，它不会返回NULL；malloc分配内存失败时<strong>返回NULL</strong>。</p>
<h2 id="4-是否需要指定内存大小">4. 是否需要指定内存大小</h2>
<blockquote>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
</blockquote>
<h2 id="5-是否调用构造函数析构函数">5. 是否调用构造函数/析构函数</h2>
<p>使用new操作符来分配对象内存时会经历三个步骤<br>
第一步：调用operator new 函数（对于数组是operator new[]）<strong>分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象</strong>。<br>
第二步：编译器运行相应的<strong>构造函数以构造对象</strong>，并为其传入初值。<br>
第三部：对象构造完成后，<strong>返回一个指向该对象的指针</strong>。</p>
<p>使用delete操作符来释放对象内存时会经历两个步骤：<br>
第一步：调用对象的<strong>析构函数</strong>。<br>
第二步：编译器调用operator delete(或operator delete[])函数<strong>释放内存空间</strong>。</p>
<blockquote>
<p>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。</p>
</blockquote>
<h2 id="6-对数组的处理">6. 对数组的处理</h2>
<p>C++提供了new[]与delete[]来专门处理数组类型:</p>
<pre><code>A * ptr = new A[10];//分配10个A对象
delete [] ptr;
</code></pre>
<p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>
<p>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>
<pre><code>int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1594524042466.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：SQL常用语句]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-sql-chang-yong-yu-ju/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-sql-chang-yong-yu-ju/">
        </link>
        <updated>2020-07-04T03:36:27.000Z</updated>
        <summary type="html"><![CDATA[<p>本文整理一下常用的SQL语句</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文整理一下常用的SQL语句</p>
<!-- more -->
<p>在本文中，我们主要是用以下实例数据库：<br>
学生-课程模式S-T：</p>
<ul>
<li>学生表（学号，姓名，性别，年龄，院系）：Student（Sno，Sname，Ssex，Sage，Sdept）</li>
<li>课程表（课程号，课程名，先行课，学分）：Course（Cno，Cname，Cpno，Ccredit）</li>
<li>学生选课表（学号，课程号，成绩）：SC（Sno，Cno，Grade）</li>
</ul>
<h2 id="1-sql的动词">1. SQL的动词</h2>
<ul>
<li>数据查询：SELECT；</li>
<li>数据定义：CREATE；DROP；ALTER；</li>
<li>数据操纵：INSERT；UPDATE；DELETE；</li>
<li>数据控制：GRANT；REVOKE；</li>
</ul>
<h2 id="2-数据定义">2. 数据定义</h2>
<table>
<thead>
<tr>
<th style="text-align:center">操作对象</th>
<th style="text-align:center">创建</th>
<th style="text-align:center">删除</th>
<th style="text-align:center">修改</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式</td>
<td style="text-align:center">CREATE SCHEMA</td>
<td style="text-align:center">DROP SCHEMA</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">表</td>
<td style="text-align:center">CREATE TABLE</td>
<td style="text-align:center">DROP TABLE</td>
<td style="text-align:center">ALTER TABLE</td>
</tr>
<tr>
<td style="text-align:center">视图</td>
<td style="text-align:center">CREATE VIEW</td>
<td style="text-align:center">DROP VIEW</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">索引</td>
<td style="text-align:center">CREATE INDEX</td>
<td style="text-align:center">DROP INDEX</td>
<td style="text-align:center">ALTER INDEX</td>
</tr>
</tbody>
</table>
<h3 id="21-关于模式">2.1 关于模式：</h3>
<h4 id="211-定义模式">2.1.1 定义模式</h4>
<blockquote>
<p>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
</blockquote>
<p>--为用户User定义一个学生-课程模式S-T<br>
<strong>CREATE SCHEMA S-T AUTHORIZATION User；</strong></p>
<p>P.s:</p>
<ol>
<li>若未指定&lt;模式名&gt;，则&lt;模式名&gt;隐含为&lt;用户名&gt;；</li>
<li>定义模式实际上定义了一个命名空间，在该命名空间中可定义该模式包含的数据库对象，如：基本表、视图、索引等。</li>
</ol>
<h4 id="212-删除模式">2.1.2 删除模式</h4>
<blockquote>
<p>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE（级联）|RESTRICT（限制）&gt;</p>
</blockquote>
<ul>
<li>CASCADE（级联）：删除模式的同时把模式中所有数据库对象全部删除；</li>
<li>RESTRICT（限制）：若该模式中定义了下属数据库对象（表、视图等），则拒绝该删除语句的执行。</li>
</ul>
<p>--级联删除模式User<br>
<strong>DROP SCHEMA User CASCADE;</strong></p>
<h3 id="22-关于表">2.2 关于表</h3>
<h4 id="221-创建表">2.2.1 创建表：</h4>
<p>CREATE TABLE &lt;表名&gt;<br>
(&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束&gt;]<br>
[,&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束&gt;]<br>
...<br>
[,&lt;表级完整性约束&gt;]<br>
)</p>
<ul>
<li>&lt;列级完整性约束&gt;：设计相应属性列的完整性约束条件；</li>
<li>&lt;表级完整性约束&gt;：设计一个或多个属性列的完整性约束条件；</li>
</ul>
<p>--建立学生表<br>
CREATE TABLE Student<br>
(<br>
Sno         CAHR(9)     PRIMARY KEY,<br>
Sname     CHAR(20)   UNIQUE,<br>
Ssex        CHAR(2),<br>
Sage        SMALLINT,<br>
Sdept       CHAR(20)<br>
);<br>
--建立课程表<br>
CREATE TABLE Course<br>
(<br>
Cno     CHAR(4) PRIMARY KEY,<br>
Cname CHAR(40),<br>
Cpno    CHAR(4),<br>
Ccredit SMALLINT,<br>
FOREIGN KEY (Cpno) REFERENCES Course(Cno)<br>
);</p>
<p>--建立学生选课表<br>
CREATE TABLE SC<br>
(<br>
Sno     CHAR(9),<br>
Cno     CHAR(4),<br>
Grade   SMALLINT,<br>
PRIMARY KEY (Sno,Cno),<br>
FOREIGN KEY (Sno) REFERENCES Student (Sno),<br>
FOREIGN KEY (Cno) REFERENCES Course (Cno)<br>
)</p>
<h4 id="222-修改表">2.2.2 修改表</h4>
<p>ALTER TABLE &lt;表名&gt;<br>
[ADD [COLUMN] &lt;列名&gt;&lt;数据类型&gt;[完整性约束]]<br>
[ADD &lt;表级完整性约束&gt;]<br>
[DROP [COLUMN] &lt;列名&gt; [CASCADE|RESTRICT]]<br>
[DROP CONSTRAINT &lt;完整性约束名&gt; [CASCADE|RESTRICT]]<br>
[ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;];</p>
<p>--向Student表中加入“入学时间”列，数据类型为日期（新增的一列均为空值）<br>
ALTER TABLE Student ADD S_entrance DATE;</p>
<p>--修改年龄数据类型为整数<br>
ALTER TABLE Student ALTER COLUMN Sage INT;</p>
<p>--增加课程名称必为唯一值的约束<br>
ALTER TABLE Course ADD UNIQUE(Cname);</p>
<h4 id="223-删除表">2.2.3 删除表</h4>
<p>DROP TABLE &lt;表名&gt; [CASCADE|RESTRICT]</p>
<ul>
<li>CASCADE：删除表时将相关依赖对象（索引、视图等）一起删除；</li>
<li>RESTRICT：删除的表不能被其他表的约束引用，否则不能删除；</li>
</ul>
<h3 id="23-模式与表">2.3 模式与表</h3>
<p>每个基本表需属于某个模式。定义基本表所属模式有如下方式：</p>
<ul>
<li>表名中显式给出：CREATE TABLE &quot;S-T&quot;.Student（...）;</li>
<li>创建模式同时创建表；</li>
<li>设置所属模式；</li>
</ul>
<p>创建基本表时，若未指定模式，系统会根据搜索路径来确定该对象所属的模式。设置搜索路径的方式：<br>
<strong>SET search_path TO &quot;S-T&quot;, PUBLIC；</strong></p>
<h3 id="24-关于索引">2.4 关于索引</h3>
<p>数据库管理系统中常见的索引：</p>
<ul>
<li>顺序文件上的索引</li>
<li>B+树索引</li>
<li>Hash索引</li>
<li>位图索引</li>
</ul>
<p>其中，B+树索引具有动态平衡的优点，Hash索引具有查找速度快的特点。</p>
<h4 id="241-建立索引">2.4.1 建立索引</h4>
<p>索引可以建立在表的一列或多列上：</p>
<p>CREATE [UNIQUE][CLUSTER] INDEX &lt;索引名&gt;<br>
ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...)</p>
<ul>
<li>表名：要建立索引的基本表的名字；</li>
<li>次序：制定索引值的排列次序——升序：ASC；降序：DESC。缺省值为ASC。</li>
<li>UNIQUE：索引的每一个索引值只对应唯一的数据记录</li>
<li>CLUSTER： 聚簇索引</li>
</ul>
<p>--为Student，Course，SC三个表建立索引。其中Student按学号升序建立唯一索引，Course按课程号升序建立唯一索引，SC按学号升序和课程号降序建立唯一索引：<br>
CREATE UNIQUE INDEX Stusno ON Student(Sno);<br>
CREATE UNIQUE INDEX Coucno ON Course(Cno);<br>
CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC);</p>
<h4 id="242-修改删除索引">2.4.2 修改/删除索引</h4>
<p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;<br>
E.g：ALTER INDEX SCno RENAME TO SCSno;</p>
<p>DROP INDEX &lt;索引名&gt;<br>
E.g：DROP INDEX Stusname;</p>
<h2 id="3-数据查询">3. 数据查询</h2>
<p>SELECT [ALL|DISTINCT] &lt;目标表达式&gt;[,&lt;目标表达式&gt;]...<br>
FROM &lt;表/视图名&gt;[,&lt;表/视图名&gt;]...|(SELECT 语句) [AS] &lt;别名&gt;<br>
[WHERE &lt;条件表达式&gt;]<br>
[GROUP &lt;列名1&gt;[HAVING &lt;条件表达式&gt;]]<br>
[ORDER BY &lt;列名2&gt; [ASC|DESC]]</p>
<ul>
<li>SELECT：指定要显示的属性列；</li>
<li>FROM：指定查询对象</li>
<li>WHERE：指定查询条件</li>
<li>GROUP BY：对查询结果按指定列分组</li>
<li>HAVING：只有满足指定条件的组才输出</li>
<li>ORDER  BY：对查询结果按列值的升序或降序排列</li>
</ul>
<h3 id="31-基础单表查询">3.1 基础单表查询</h3>
<p>E.g：<br>
“查询全体学生姓名及出生年份”：<br>
SELECT Sname，2020-Sage From Student；</p>
<p>“查询全体学生姓名，出生年份和所在院系（小写字母表示系名）”：<br>
SELECT Sname，2020-Sage，LOWER(Sdept) FROM Student；</p>
<p>【使用别名】：<br>
SELECT Sname NAME，2020-Sage BIRTHDAY FROM Student；</p>
<p>【消除重复行】（不指定DISTINCT关键词，则缺省为ALL）：<br>
SELECT DISTINCT Sno FROM SC；</p>
<p>【大小比较】：<br>
SELECT Sname FROM Student WHERE Sdept=‘CS’；<br>
SELECT Sname，Sage FROM Student WHERE Sage&lt;20 AND Sage&gt;17；</p>
<p>【范围】：<br>
SELECT Sname，Sage FROM Student WHERE Sage （NOT） BETWEEN 20 AND 23；</p>
<p>【集合】：<br>
SELECT Sname，Sage FROM Student WHERE Sdept （NOT） IN（‘CS’，‘MA’，‘IS’）；</p>
<p>【字符匹配】（‘%’：任意长度字符；‘<em>’：任意单个字符）：<br>
SELECT * FROM Student WHERE Sno （NOT）LIKE ‘2018216020’；<br>
SELECT * FROM Student WHERE Sno （NOT）LIKE ‘刘%’；<br>
SELECT * FROM Course WHERE Cname （NOT）LIKE ‘DB_%i</em> <em>’ ESCAPE ‘\’；（查询以‘DB</em>’开头且倒数第三个字符为i的课程信息，ESCAPE ‘\’说明\为转码符号）。</p>
<p>【空值】<br>
SELECT Sno，Cno FROM SC WHERE Grade IS（NOT）NULL；</p>
<h3 id="32-进阶单表查询">3.2 进阶单表查询：</h3>
<h4 id="321-order-by-子句">3.2.1 ORDER BY 子句</h4>
<p>【ORDER BY】按一个或多个属性排序（ASC——升序（默认）；DESC——降序）：<br>
SELECT Sno，Grade<br>
FROM SC<br>
WHERE Cno=‘3’<br>
ORDER BY Grade DESC；</p>
<h4 id="322-聚集函数">3.2.2 聚集函数</h4>
<ul>
<li>统计元组个数：COUNT（*）</li>
<li>统计一列中值得个数：COUNT （[DISTINCT｜ALL]&lt;列名&gt;）</li>
<li>计算一列总和：SUM（[DISTINCT｜ALL]&lt;列名&gt;）</li>
<li>计算一列平均值：AVG（[DISTINCT｜ALL]&lt;列名&gt;）</li>
<li>求一列最值：MAX/MIN（[DISTINCT｜ALL]&lt;列名&gt;）</li>
</ul>
<p>SELECT COUNT（*）FROM Student；<br>
SELECT COUNT（DISTINCT Sno） FROM SC；<br>
SELECT AVG（Grade）FROM SC WHERE Cno=‘1’；</p>
<h4 id="323-group-by-子句">3.2.3 GROUP BY 子句</h4>
<p>细化聚集函数作用对象：</p>
<ul>
<li>未对查询结果分组，<strong>聚集函数将作用在整个查询结果</strong>；</li>
<li>对查询结果分组，<strong>聚集函数会作用在每个组</strong>；</li>
</ul>
<p>求各门课程相应的选课人数：<br>
SELECT Cno，COUNT（Sno）<br>
FROM SC<br>
GROUP BY Cno；<br>
<img src="https://mocuishle0.github.io//post-images/1594609759383.png" alt="" loading="lazy"></p>
<p>查询选了三门以上课程的学生学号<br>
SELECT Sno<br>
FROM SC<br>
GROUP BY Sno<br>
HAVING COUNT（*）&gt;3;</p>
<blockquote>
<p>P.s：WHERE 与 HAVING 区别<br>
作用对象不同<br>
WHERE子句作用于基本表或视图，从中选择满足条件的元组；<br>
HAVING短语作用于组，从中选择满足条件的组；<br>
WHERE子句中不能用聚集函数作为条件表达式；</p>
</blockquote>
<h2 id="33-连接查询">3.3 连接查询</h2>
<h3 id="331-等值非等值连接查询">3.3.1 等值&amp;非等值连接查询</h3>
<p><strong>等值连接</strong>：<br>
SELECT Student.<em>, SC.</em><br>
FROM Student, SC<br>
WHERE Student.Sno=SC.Sno;<br>
<img src="https://mocuishle0.github.io//post-images/1594610358294.png" alt="" loading="lazy"></p>
<p><strong>自然连接</strong>：<br>
SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade<br>
FROM Student,SC<br>
WHERE Student.Sno=SC.Sno;</p>
<blockquote>
<p><strong>连接操作执行过程：</strong><br>
（1）嵌套循环：多重循环嵌套<br>
（2）排序合并（常用于等值连接）：先排序后连接<br>
（3）索引连接：建立索引进而连接</p>
</blockquote>
<h3 id="332-自身连接">3.3.2 自身连接</h3>
<p>一个表与自身进行连接。需要通过别名以示区别：<br>
SELECT FIRST.Cname,SECOND.Cname<br>
FROM Course FIRST,Course SECOND<br>
WHERE FIRST.Cpno=SECOND.cno;<br>
<img src="https://mocuishle0.github.io//post-images/1594610926638.png" alt="" loading="lazy"></p>
<h3 id="333-外连接">3.3.3 外连接</h3>
<p>普通连接仅输出满足连接条件的元组，而外连接则以指定表为连接主体，将主体表中不满足的元组一并输出：</p>
<ul>
<li>左外连接：列出左边关系中所有的元组；</li>
<li>右外连接：列出右边关系中所有的元组；</li>
</ul>
<p>SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade<br>
FROM Student LEFT OUT JOIN SC ON（Student.Sno=SC.Sno）;<br>
<img src="https://mocuishle0.github.io//post-images/1594611164461.png" alt="" loading="lazy"></p>
<h2 id="4-数据更新">4. 数据更新</h2>
<h3 id="41-插入数据">4.1 插入数据</h3>
<p><strong>A. 插入元组</strong><br>
INSERT INTO &lt;表名&gt;[(&lt;属性1&gt;[,&lt;属性2&gt;]...)]<br>
VALUES (&lt;常量1&gt;[,&lt;常量2&gt;]...)；</p>
<p>E.g：<br>
INSERT INTO Student（Sno，Sname，Ssex，Sdept，Sage）<br>
VALUES （‘2018216020’，‘Li’，‘男’，‘CS’，‘18’）；</p>
<p><strong>B. 插入子查询结果</strong><br>
INSERT INTO &lt;表名&gt;[(&lt;属性1&gt;[,&lt;属性2&gt;]...)]<br>
子查询</p>
<p>E.g：<br>
INSERT INTO Dept_age（Sdept，Avg_age）<br>
SELECT Sdept，AVG（Sage）<br>
FROM Student<br>
GROUP BY Sdept；</p>
<h3 id="42-数据修改">4.2 数据修改</h3>
<p>UPDATE &lt;表名&gt;<br>
SET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]...<br>
[WHERE &lt;条件&gt;];</p>
<p>存在三种修改方式：</p>
<ul>
<li>修改某一个元组的值；</li>
<li>修改多个元组的值；</li>
<li>带子查询的修改语句；</li>
</ul>
<p>【将学号为2018216020的年龄改为24岁】：<br>
UPDATE Student<br>
SET Sage=24<br>
WHERE Sno=‘2018216020’；</p>
<p>【将所有学生年龄+1】<br>
UPDATE Student<br>
SET Sage=Sage+1；</p>
<p>【将计算机专业全体学生成绩置0】<br>
UPDATE SC<br>
SET Grade=0<br>
WHERE Sno IN<br>
（SELECT Sno FROM WHERE Sdept=‘CS’）；</p>
<h3 id="43-删除数据">4.3 删除数据</h3>
<p>DELETE FROM &lt;表名&gt;<br>
[WHERE &lt;条件&gt;]</p>
<p>功能：删除指定表中满足WHERE子句条件的元组<br>
存在三种删除方式：</p>
<ul>
<li>删除某一个元组的值</li>
<li>删除多个元组的值；</li>
<li>带子查询的删除语句；</li>
</ul>
<p>【将学号为2018216020学生记录删除】<br>
DELETE FROM Student<br>
WHERE Sno=‘2018216020’；</p>
<p>【删除所有学生的选课记录】<br>
DELETE FROM SC；</p>
<p>【删除计算机系所有学生的选课记录】<br>
DELETE FROM SC<br>
WHERE Sno IN<br>
（SELECT Sno FROM Student WHERE Sdept=‘CS’）；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：数据库系统结构]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-shu-ju-ku-xi-tong-jie-gou/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-shu-ju-ku-xi-tong-jie-gou/">
        </link>
        <updated>2020-07-04T02:20:26.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍关于数据库系统的三级模式与数据独立性的相关知识。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍关于数据库系统的三级模式与数据独立性的相关知识。</p>
<!-- more -->
<p>本文主要内容：</p>
<ul>
<li>模式与实例</li>
<li>数据库系统的三级模式结构</li>
<li>数据库的二级映像与数据独立性</li>
</ul>
<h2 id="1-模式schema实例instance">1. 模式（Schema）&amp;实例（Instance）</h2>
<p>模式与实例其本质就是“型”与“值”的关系：<br>
<strong>模式（Schema）：</strong><br>
* 是对数据库逻辑结构和特征的描述；<br>
* 模式是相对稳定的<br>
* 是对型的描述，不涉及具体值</p>
<p>E.g：“学生选课数据库”：<br>
<img src="https://mocuishle0.github.io//post-images/1593829964496.png" alt="" loading="lazy"></p>
<p><strong>实例（Instance）：</strong><br>
* 数据库某一时刻的状态，即为模式的一个具体值<br>
* 同一个模式可以有多个实例<br>
* 实例会随数据库中数据更新而变动</p>
<p>E.g：“各年学生选课实例”：<br>
<img src="https://mocuishle0.github.io//post-images/1593829990708.png" alt="" loading="lazy"></p>
<h2 id="2-数据库系统的三级模式">2. 数据库系统的三级模式</h2>
<p>所谓数据库的三级模式，即：外模式-模式-内模式，如图所示：<br>
<img src="https://mocuishle0.github.io//post-images/1593830015412.png" alt="" loading="lazy"></p>
<h3 id="21-模式逻辑模式">2.1 模式（逻辑模式）：</h3>
<p>模式（逻辑模式）是对数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
<ul>
<li>模式是数据库系统模式结构的中心：
<ul>
<li>与数据的物理存储细节和硬件环境无关；</li>
<li>与具体应用程序、开发工具以及高级程序设计语言无关；</li>
</ul>
</li>
<li>定义模式：
<ul>
<li>定义数据间联系；</li>
<li>定义数据相关的安全性、完整性要求；</li>
</ul>
</li>
</ul>
<h3 id="22-外模式">2.2 外模式：</h3>
<p>外模式是对用户使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示。</p>
<ul>
<li>外模式通常是模式的子集，一个模式通常可以有多个外模式以反映用户的不同应用需求；</li>
<li>一个外模式可以被多个应用系统所使用，但一个应用程序只能使用一个外模式；</li>
<li>外模式用途：
<ul>
<li>每个用户只能看到和访问1所对应的外模式中的数据，简化了用户视图；</li>
<li>提供了安全保障</li>
</ul>
</li>
</ul>
<h3 id="23-内模式存储模式">2.3 内模式（存储模式）：</h3>
<p>内模式是对数据物理结构和存储方式的描述，是数据在数据库内部的表示方式，包括：</p>
<ul>
<li>记录的存储方式——顺序、堆存储、hash存储</li>
<li>索引的组织方式——B+树、Hash</li>
<li>数据是否压缩存储、是否加密等<br>
<strong>一个数据库只有一个内模式。</strong></li>
</ul>
<h2 id="3-数据库的二级映像与数据独立性">3. 数据库的二级映像与数据独立性</h2>
<h3 id="31-数据库的二级映像">3.1 数据库的二级映像：</h3>
<p>数据库的三级模式对应了数据库的二级映像：</p>
<ul>
<li>外模式——模式映像：保证数据的逻辑独立性，即：模式改变时，仅需要对外模式——模式映像进行改变即可，无需改变应用程序</li>
<li>模式——内模式映像：保证数据的物理独立性，即：数据存储结构改变时，仅需要对模式——内模式映像进行改变即可，无需改变模式。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：关系模型]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-guan-xi-mo-xing/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-guan-xi-mo-xing/">
        </link>
        <updated>2020-07-04T01:54:06.000Z</updated>
        <summary type="html"><![CDATA[<p>数据模型是对现实世界数据特征的抽象，其可被分为：概念模型、逻辑模型和物理模型两类。本文主要介绍最为常用的一类数据模型——关系模型。</p>
]]></summary>
        <content type="html"><![CDATA[<p>数据模型是对现实世界数据特征的抽象，其可被分为：概念模型、逻辑模型和物理模型两类。本文主要介绍最为常用的一类数据模型——关系模型。</p>
<!-- more -->
<p>本文主要内容：</p>
<ul>
<li>关系模型数据结构</li>
<li>关系模型的数据操纵</li>
<li>关系模型的完整性约束</li>
</ul>
<p>首先需要明确的是：<strong>关系数据库系统采用关系模型作为数据的组织方式</strong>。</p>
<h2 id="1-关系模型的数据结构">1. 关系模型的数据结构：</h2>
<p>在用户观点下，关系模型中的逻辑结构是一张<strong>二维表</strong>：</p>
<ul>
<li>关系（Relation）：一张表；</li>
<li>元组（Tuple）：表中一行即为一个元组；</li>
<li>属性（Attribute）：表中一列即为一个属性；</li>
<li>主键（Key）：某个属性组，可用于确定一个元组；</li>
<li>域（Domain）：一组具有相同数据类型的值的集合；</li>
<li>分量：元组中的一个属性值；</li>
<li>关系模式：对关系的描述</li>
</ul>
<p>P.s：关系必须是规范化的，最基本的规范条件——关系中的每个分量必须是一个不可分的数据项。具体参见后续关于范式的介绍。</p>
<h2 id="2-关系模型的数据操纵">2. 关系模型的数据操纵</h2>
<p>数据操作是集合操作，操作对象与结果均为关系：</p>
<ul>
<li>查询</li>
<li>插入</li>
<li>删除</li>
<li>更新</li>
</ul>
<h2 id="3-关系模型的完整性约束">3. 关系模型的完整性约束</h2>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义完整性</li>
</ul>
<h3 id="31-实体完整性">3.1 实体完整性</h3>
<p>主属性（候选码的诸项属性）不能为空值；<br>
P.s：</p>
<ul>
<li>候选码——关系中某一属性组能唯一表示一个元组。</li>
<li>现实世界中实体都是可区分的，若主属性为空值说明存在不可区分的实体。</li>
</ul>
<h3 id="32-参照完整性">3.2 参照完整性</h3>
<p>即关系间的参照关系——外码。<br>
P.s：外码可取空值。</p>
<h2 id="4-关系模型的优缺点">4. 关系模型的优缺点</h2>
<ul>
<li>
<p>优点：</p>
<ul>
<li>建立在严格的数学概念上；</li>
<li>概念单一——实体和各类联系均用关系表示，检索结果也是关系；</li>
<li>关系模型存取路径对用户透明</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>查询效率往往不如格式化数据模型</li>
<li>对用户给定的查询请求往往会进行优化，增加了开发难度</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库：数据库系统概述]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-ku-shu-ju-ku-xi-tong-gai-shu/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-ku-shu-ju-ku-xi-tong-gai-shu/">
        </link>
        <updated>2020-07-04T01:31:48.000Z</updated>
        <summary type="html"><![CDATA[<p>从今天开始逐步整理一些关于数据库系统的知识，以应对面试中的一些相关问题。今天就先从系统概述开始：</p>
]]></summary>
        <content type="html"><![CDATA[<p>从今天开始逐步整理一些关于数据库系统的知识，以应对面试中的一些相关问题。今天就先从系统概述开始：</p>
<!-- more -->
<p>本文主要内容：</p>
<ul>
<li>四大概念</li>
<li>数据库管理系统主要功能</li>
<li>数据库系统特点</li>
</ul>
<h2 id="1-四大概念">1. 四大概念：</h2>
<ol>
<li>数据（Data）；</li>
<li>数据库（DataBase）：<strong>长期存储</strong>在计算机内，<strong>有组织、可共享</strong>的大量数据的集合；</li>
<li>数据库管理系统（DBMS）：科学地<strong>组织和存储</strong>数据，并高效地<strong>获取和维护</strong>数据；</li>
<li>数据库系统（DBS）：不引起混淆的情况下，常将数据库系统简称为数据库；</li>
</ol>
<h2 id="2-数据库管理系统主要功能">2. 数据库管理系统主要功能：</h2>
<ol>
<li>数据定义功能</li>
<li>数据组织、存储和管理；</li>
<li>数据操纵功能（查询、插入、删除、修改等）</li>
<li>数据库的事务管理和运行功能</li>
<li>数据库的建立和维护功能</li>
<li>其他功能</li>
</ol>
<h2 id="3-数据库系统特点">3. 数据库系统特点</h2>
<ol>
<li>数据结构化</li>
<li>数据共享性高、冗余度低、易扩充</li>
<li>数据独立性高</li>
<li>数据有数据库管理系统统一管理；</li>
</ol>
<p>P.s：<strong>关于数据独立性</strong><br>
所谓数据库中的数据独立性包括：物理独立性、逻辑独立性两个方面：</p>
<ul>
<li>物理独立性：用户的应用程序与数据库中数据的物理存储是相互独立的——数据的物理存储改变，不影响应用程序；</li>
<li>逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的——数据的逻辑结构改变了，不影响应用程序。</li>
<li><strong>数据独立性有数据库管理系统的二级映像功能来保证。</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构：哈希 Hash]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-jie-gou-ha-xi-hash/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-jie-gou-ha-xi-hash/">
        </link>
        <updated>2020-06-17T10:01:31.000Z</updated>
        <summary type="html"><![CDATA[<p>整理一下关于哈希冲突的解决策略</p>
]]></summary>
        <content type="html"><![CDATA[<p>整理一下关于哈希冲突的解决策略</p>
<!-- more -->
<h2 id="1-开放地址法再散列法">1. 开放地址法（再散列法）</h2>
<p>当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>i</mi><mo>=</mo><mo>(</mo><mi>H</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Hi=(H(key)+d_i)%m，i=1，2，…，n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>为哈希函数，m 为表长，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称为增量序列。<strong>增量序列的取值方式不同</strong>，相应的再散列方式也不同。主要有以下几种：</p>
<h3 id="11-线性探测法">1.1 线性探测法：</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>m</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">d_i=1,2,3,\dotsb,m−1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord">−</span><span class="mord">1</span></span></span></span></span></p>
<p>这种方法的特点是：冲突发生时，<strong>顺序</strong>查看表中下一单元，直到找出一个空单元或查遍全表。<br>
<strong>建立在两个假设基础上：（1）表格足够大（2）每个元素都能够独立</strong></p>
<h3 id="12-二次探测法">1.2 二次探测法：</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">−</mi><msup><mn>1</mn><mn>2</mn></msup><mi mathvariant="normal">，</mi><msup><mn>2</mn><mn>2</mn></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">−</mi><msup><mn>2</mn><mn>2</mn></msup><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><msup><mi>k</mi><mn>2</mn></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">−</mi><msup><mi>k</mi><mn>2</mn></msup><mtext> </mtext><mo>(</mo><mi>k</mi><mo>≤</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">d_i=1^2，−1^2，2^2，−2^2，…，k^2，−k^2 \ (k\leq m/2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>
<p>这种方法的特点是：冲突发生时，在表的左右进行<strong>跳跃式探测</strong>，比较灵活。</p>
<h3 id="13-伪随机探测法">1.3 伪随机探测法：</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi mathvariant="normal">伪</mi><mi mathvariant="normal">随</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">列</mi></mrow><annotation encoding="application/x-tex">d_i=伪随机数序列
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">伪</span><span class="mord cjk_fallback">随</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">列</span></span></span></span></span></p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p)%m），并给定一个随机数做起点。</p>
<h3 id="14-示例">1.4 示例：</h3>
<p>已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则对于序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>47</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>60</mn><mo separator="true">,</mo><mn>69</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{47,26,60,69\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">4</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">9</span><span class="mclose">}</span></span></span></span>有<br>
H（47）=3，H（26）=4，H（60）=5，H（69）=3，69与47冲突:</p>
<ul>
<li>
<p><strong>线性探测再散列处理冲突：</strong><br>
下一个哈希地址为H1=（3+1）%11=4,<br>
仍然冲突，再找下一个哈希地址为H2=（3+2）%11=5<br>
还是冲突，继续找下一个哈希地址为H3=（3+3）%11=6<br>
此时不再冲突，将69填入6号单元。<br>
平均查找长度为 (1+1+1+4)/4=7/4</p>
</li>
<li>
<p><strong>用二次探测再散列处理冲突：</strong><br>
下一个哈希地址为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mn>1</mn><mo>=</mo><mi mathvariant="normal">（</mi><mn>3</mn><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">H1=（3+1^2）%11=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span><br>
仍然冲突，再找下一个哈希地址为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mn>2</mn><mo>=</mo><mi mathvariant="normal">（</mi><mn>3</mn><mi mathvariant="normal">−</mi><msup><mn>1</mn><mn>2</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">H2=（3−1^2）%11=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord">3</span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span><br>
此时不再冲突，将69填入2号单元<br>
平均查找长度为 (1+1+1+3)/4=6/4</p>
</li>
<li>
<p><strong>用伪随机探测再散列处理冲突：</strong><br>
若伪随机数序列为：2，5，9，……..，<br>
则下一个哈希地址为H1=（3+2）%11=5<br>
仍然冲突，再找下一个哈希地址为H2=（3+5）%11=8<br>
此时不再冲突，将69填入8号单元。<br>
平均查找长度为 (1+1+1+3)/4=6/4</p>
</li>
</ul>
<h2 id="2-链地址法拉链法">2. 链地址法（拉链法）：</h2>
<p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。</p>
<p>例如，已知一组关键字（32，40，36，53，16，46，71，27，42，24，49，64），哈希表长度为13，哈希函数为：H（key）=key%13，如图：<br>
<img src="https://mocuishle0.github.io//post-images/1592443779588.gif" alt="" loading="lazy"></p>
<p>由于链表的特点是：<strong>寻址困难，插入和删除容易，链地址法适用于经常进行插入和删除的情况。</strong></p>
<h2 id="3-公共溢出区法">3. 公共溢出区法：</h2>
<p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h2 id="4-再哈希法">4. 再哈希法：</h2>
<p>这种方法是同时构造多个不同的哈希函数：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mi>R</mi><msub><mi>H</mi><mi>i</mi></msub><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mtext> </mtext><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">H_i=RH_i(key),\ i=1,2,\dotsb , k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p>当哈希地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mi>R</mi><msub><mi>H</mi><mn>1</mn></msub><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H_i=RH_1(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>发生冲突时，再计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><mi>R</mi><msub><mi>H</mi><mn>2</mn></msub><mo>(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">H_i=RH_2(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>……，直到冲突不再产生。<br>
这种方法不易产生聚集，但增加了计算时间。</p>
<h2 id="ps-hash法查找效率">P.s hash法查找效率：</h2>
<p>我们可以看到，哈希表存储和查找数据的时候分为两步，第一步为将关键字通过哈希函数映射为数组中的索引， 这个过程可以认为是只需要常数时间的。第二步是，如果出现哈希值冲突，如何解决，对于常用的拉链法和线性探测法我们可以讨论得到：</p>
<p>对于拉链法，查找的效率在于链表的长度，一般的我们应该保证长度在m /8~m /2之间，如果链表的长度大于m /2，我们可以缩小链表长度。如果长度在0~M/8时，我们可以扩充链表。</p>
<p>对于线性探测法，需要调整数组长度，但是动态调整数组的大小需要对所有的值从新进行重新散列并插入新的表中。因此，拉链法的查找效率要比线性探测法高。</p>
<p>不管是拉链法还是散列法，这种动态调整链表或者数组的大小以提高查询效率的同时，还应该考虑动态改变链表或者数组大小的成本。散列表长度加倍的插入需要进行大量的探测， 这种均摊成本不能忽略。</p>
<p>此外，hash表的查找效率还和负载因子有关，**负载因子即hash表的记录数与哈希表的长度的比值，一般为0.7左右。**冲突性的概率与负载因子的大小成正比，因此负载因子越大，查找效率越低。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：可变参数模板(variadic template)]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-ke-bian-can-shu-mo-ban-variadic-template/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-ke-bian-can-shu-mo-ban-variadic-template/">
        </link>
        <updated>2020-06-13T07:31:10.000Z</updated>
        <summary type="html"><![CDATA[<p>泛化之美~</p>
]]></summary>
        <content type="html"><![CDATA[<p>泛化之美~</p>
<!-- more -->
<p>C++11的新特性--可变模版参数（variadic templates）是C++11新增的最强大的特性之一，它对参数进行了高度泛化，它能表示0到任意个数、任意类型的参数。相比C++98/03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以它也是C++11中最难理解和掌握的特性之一。虽然掌握可变模版参数有一定难度，但是它却是C++11中最有意思的一个特性。</p>
<h2 id="1-可变模版参数的定义">1. 可变模版参数的定义</h2>
<p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，<strong>声明可变参数模板时需要在typename或class后面带上省略号“...”</strong>。比如我们常常这样声明一个可变模版参数：template&lt;typename...&gt;或者template&lt;class...&gt;。具体如下:</p>
<pre><code>template &lt;class... T&gt;
void f(T... args);
</code></pre>
<p>上面的可变模版参数的定义当中，省略号的作用有两个：</p>
<ol>
<li>声明一个参数包T... args，这个参数包中可以包含0到任意个模板参数；</li>
<li>在模板定义的右边，可以将参数包展开成一个一个独立的参数。</li>
</ol>
<p>上面的参数args前面有省略号，所以它就是一个可变模版参数，<strong>我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;=0）个模版参数</strong>。我们<strong>无法直接获取参数包args中的每个参数的</strong>，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。</p>
<h2 id="2-可变模版参数函数">2. 可变模版参数函数</h2>
<pre><code>template &lt;class... T&gt;
void f(T... args)
{    
    cout &lt;&lt; sizeof...(args) &lt;&lt; endl; //打印变参的个数
}

f();        //0
f(1, 2);    //2
f(1, 2.5, &quot;&quot;);    //3
</code></pre>
<p>这个例子只是简单的将可变模版参数的个数打印出来，如果我们需要将参数包中的每个参数打印出来的话就需要通过一些方法了。展开可变模版参数函数的方法一般有两种：<strong>一种是通过递归函数来展开参数包，另外一种是通过逗号表达式来展开参数包</strong>。下面来看看如何用这两种方法来展开参数包。</p>
<h3 id="21-递归函数方式展开参数包">2.1 递归函数方式展开参数包</h3>
<pre><code>#include &lt;iostream&gt;
using namespace std;
//递归终止函数
void print()
{
   cout &lt;&lt; &quot;empty&quot; &lt;&lt; endl;
}
//展开函数
template &lt;class T, class ...Args&gt;
void print(T head, Args... rest)
{
   cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;
   print(rest...);
}


int main(void)
{
   print(1,2,3,4);
   return 0;
}
</code></pre>
<p>上例会输出每一个参数，直到为空时输出empty。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包Args...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。<br>
上面的递归终止函数还可以写成这样，当参数包展开到最后一个参数时递归为止。</p>
<pre><code>template &lt;class T&gt;
void print(T t)
{
   cout &lt;&lt; t &lt;&lt; endl;
}
</code></pre>
<p>此外，我们在给出一个示例，该示例于上一示例原理一致</p>
<pre><code>template&lt;typename T&gt;
T sum(T t)
{
    return t;
}
template&lt;typename T, typename ... Types&gt;
T sum (T first, Types ... rest)
{
    return first + sum&lt;T&gt;(rest...);
}

sum(1,2,3,4); //10
</code></pre>
<h3 id="22-逗号表达式展开参数包">2.2 逗号表达式展开参数包</h3>
<p>递归函数展开参数包是一种标准做法，也比较好理解，但也有一个缺点，就是必须要一个重载的递归终止函数，即必须要有一个同名的终止函数来终止递归，这样可能会感觉稍有不便。有没有一种更简单的方式呢？其实还有一种方法可以不通过递归方式来展开参数包，这种方式需要借助逗号表达式和初始化列表。比如前面print的例子可以改成这样：</p>
<pre><code>template &lt;class T&gt;
void printarg(T t)
{
   cout &lt;&lt; t &lt;&lt; endl;
}

template &lt;class ...Args&gt;
void expand(Args... args)
{
   int arr[] = {(printarg(args), 0)...};
}

expand(1,2,3,4);
</code></pre>
<p>这个例子将分别打印出1,2,3,4四个数字。这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的。<strong>printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数</strong>。这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式，比如：</p>
<pre><code>d = (a = b, c); 
</code></pre>
<p>这个表达式会按顺序执行：b会先赋值给a，接着括号中的逗号表达式返回c的值，因此d将等于c。</p>
<p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，<strong>通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0),  etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]</strong>。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。</p>
<h2 id="3-可变模版参数类">3. 可变模版参数类</h2>
<p>可变参数模板类是一个带可变模板参数的模板类，比如C++11中的元祖std::tuple就是一个可变模板类，它的定义如下：</p>
<pre><code>template&lt; class... Types &gt;
class tuple;
</code></pre>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：</p>
<pre><code>std::tuple&lt;&gt; tp;        //可变参数模板的模板参数个数可以为0个，所以该定义也是合法的：
std::tuple&lt;int&gt; tp1 = std::make_tuple(1);
std::tuple&lt;int, double&gt; tp2 = std::make_tuple(1, 2.5);
std::tuple&lt;int, double, string&gt; tp3 = std::make_tuple(1, 2.5, “”);
</code></pre>
<p>可变参数模板类的参数包展开的方式和可变参数模板函数的展开方式不同，<strong>可变参数模板类的参数包展开需要通过模板特化和继承方式去展开，展开方式比可变参数模板函数要复杂</strong>。</p>
<p>具体方法可参考：[泛化之美--C++11可变模版参数的妙用]{https://www.cnblogs.com/qicosmos/p/4325949.html}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构：二叉树]]></title>
        <id>https://mocuishle0.github.io/post/shu-ju-jie-gou-er-cha-shu/</id>
        <link href="https://mocuishle0.github.io/post/shu-ju-jie-gou-er-cha-shu/">
        </link>
        <updated>2020-06-11T02:52:20.000Z</updated>
        <summary type="html"><![CDATA[<p>二叉树向来都是一个极其重要的数据结构。此外，二叉树还衍生出众多数据结构，如：B树、B+树、红黑树等。本文将根据近期看到的一些讲解，对该专题进行一个归纳。</p>
]]></summary>
        <content type="html"><![CDATA[<p>二叉树向来都是一个极其重要的数据结构。此外，二叉树还衍生出众多数据结构，如：B树、B+树、红黑树等。本文将根据近期看到的一些讲解，对该专题进行一个归纳。</p>
<!-- more -->
<h2 id="1-二叉查找树bst">1. 二叉查找树（BST）</h2>
<h3 id="11-特点">1.1 特点</h3>
<ul>
<li>左子树上所有结点的值均小于或等于它的根结点的值。</li>
<li>右子树上所有结点的值均大于或等于它的根结点的值。</li>
<li>左、右子树也分别为二叉排序树。<br>
示例如图：<br>
<img src="https://mocuishle0.github.io//post-images/1591845027043.webp" alt="" loading="lazy"></li>
</ul>
<h3 id="12-缺陷">1.2 缺陷</h3>
<p>单纯的二叉查找树不包含“调节功能”，这使得在一些极端情况下导致其查询效率大打折扣，甚至退回到线性查找，如图：<br>
<img src="https://mocuishle0.github.io//post-images/1591845396453.webp" alt="" loading="lazy"><br>
该示例虽然满足二叉查找树的特征，但显然其查询效率近似于线性查找。</p>
<h2 id="2-平衡二叉树">2. 平衡二叉树</h2>
<h3 id="21-特点">2.1 特点</h3>
<p>平衡二叉树实质仍然是一棵二叉查找树。其采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p>
<ul>
<li>非叶子节点只能允许最多两个子节点存在；</li>
<li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；</li>
<li><strong>树的左右两边的节点层级相差不会大于1</strong>。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1591845534214.png" alt="" loading="lazy"></figure>
<h3 id="22-层级结构">2.2 层级结构</h3>
<p>因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如Treap、红黑树。<strong>使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1</strong>，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p>
<h3 id="23-小结">2.3 小结</h3>
<ul>
<li>非叶子节点最多拥有两个子节点；</li>
<li>非叶子节值大于左边子节点、小于右边子节点；</li>
<li>树的左右两边的层级数相差不会大于1;</li>
<li>没有值相等重复的节点;</li>
</ul>
<h2 id="3-红黑树">3 红黑树</h2>
<h3 id="31-红黑树特性">3.1 红黑树特性</h3>
<p>红黑树其实质是一棵平衡二叉树。只是红黑树增加了一些特性来保证其平衡性：</p>
<ul>
<li>结点是红色或黑色。</li>
<li>根结点是黑色。</li>
<li>每个叶子结点都是黑色的空结点（NIL结点）。</li>
<li><strong>每个红色结点的两个子结点都是黑色</strong>。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</li>
<li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</strong>。<br>
<img src="https://mocuishle0.github.io//post-images/1591845904948.webp" alt="" loading="lazy"></li>
</ul>
<p>P.s：正是由于上述规则的限制，才保证了红黑树的自平衡，并保证了红黑树上从根到叶子最长路径不超过最短路径的2倍。</p>
<h3 id="32-红黑树的自平衡">3.2 红黑树的自平衡</h3>
<p>正如之前我们所说，平衡二叉树的核心是：<strong>树的左右两边的节点层级相差不会大于1</strong>。红黑树作为一棵特殊的平衡二叉树，其在插入/删除节点时容易打破其规则约束，此时需要对树的结构进行一些调整来维护其仍然满足红黑素性质。<br>
红黑树维护自平衡性的方法总结来看有两种：</p>
<ul>
<li>变色</li>
<li>旋转：
<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
</li>
</ul>
<p>由于红黑树的自平衡维护需要根据不同情况具体分析，参考文献：<a href="https://mp.weixin.qq.com/s/X3zYwQXxq93P_XUzFmKluQ">红黑树</a>中对这一过程有具体的说明，此处便不详细展开了。</p>
<h2 id="4-b树">4. B树</h2>
<p>B树和平衡二叉树稍有不同的是，<strong>B树属于多叉树又名平衡多路查找树（查找路径不只两个）</strong>。B树和B+树被广泛应用于数据库索引技术中。</p>
<h3 id="41-b树特性">4.1 B树特性</h3>
<ul>
<li>排序方式：所有节点<strong>关键字是按递增次序排列</strong>，并遵循左小右大原则；</li>
<li>子节点数：**非叶节点的子节点数&gt;1，且&lt;=M **，且M&gt;=2，空树除外（注：<strong>M代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉</strong>）；</li>
<li>关键字数：<strong>枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个</strong>（注：ceil()向上取整的函数 如ceil(1.1)结果为2);</li>
<li><strong>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</strong>;</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://mocuishle0.github.io//post-images/1591846623300.jpg" alt="" loading="lazy"></figure>
<h3 id="42-b树查询">4.2 B树查询</h3>
<p>其查询过程类似于二分查找</p>
<h3 id="43-b树插入">4.3 B树插入</h3>
<p>例如：定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来；我们需要遵循以下规则：</p>
<ul>
<li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</li>
<li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</li>
</ul>
<p>我们首先插入 3、8、31、11：<br>
<img src="https://mocuishle0.github.io//post-images/1591847056750.jpg" alt="" loading="lazy"><br>
再插入23、29<br>
<img src="https://mocuishle0.github.io//post-images/1591847098035.jpg" alt="" loading="lazy"><br>
再插入50、28<br>
<img src="https://mocuishle0.github.io//post-images/1591847122970.jpg" alt="" loading="lazy"></p>
<h3 id="44-b树删除">4.4 B树删除</h3>
<p>当我们需要删除B树中的节点时，需遵循以下规则：</p>
<ul>
<li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）；</li>
<li>满足节点本身比左边节点大，比右边节点小的排序规则;</li>
<li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://mocuishle0.github.io//post-images/1591847499673.png" alt="" loading="lazy"></figure>
<h3 id="45-b树小结">4.5 B树小结</h3>
<p>B树相对于平衡二叉树的不同是，每个<strong>节点包含的关键字增多了</strong>，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制在充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
]]></content>
    </entry>
</feed>