<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mocuishle0.github.io/</id>
    <title>MoCuishle</title>
    <updated>2020-06-07T03:02:43.262Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mocuishle0.github.io/"/>
    <link rel="self" href="https://mocuishle0.github.io/atom.xml"/>
    <subtitle>我拥有的都是侥幸，
我失去的都是人生。</subtitle>
    <logo>https://mocuishle0.github.io/images/avatar.png</logo>
    <icon>https://mocuishle0.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MoCuishle</rights>
    <entry>
        <title type="html"><![CDATA[C++：内存分配方式]]></title>
        <id>https://mocuishle0.github.io/post/cnei-cun-fen-pei-fang-shi/</id>
        <link href="https://mocuishle0.github.io/post/cnei-cun-fen-pei-fang-shi/">
        </link>
        <updated>2020-06-07T02:22:38.000Z</updated>
        <summary type="html"><![CDATA[<p>C++的内存分配方式是理解C++特征的基础。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++的内存分配方式是理解C++特征的基础。</p>
<!-- more -->
<p>首先，我们主要根据《C++ Primer Plus》中的介绍进行一个总结：C++有三种管理数据内存的方式——<strong>自动存储、静态存储和动态存储</strong>（也称为自由存储空间 或 堆）。在C++11中还新增了线程存储，这将在后续文章中介绍。本文主要就自动存储、静态存储和动态存储进行归纳整理。</p>
<h2 id="1-堆和栈">1. 堆和栈</h2>
<h3 id="11-概念">1.1 概念</h3>
<p>在具体介绍三类存储方式之前，我们先明确堆和栈的概念：</p>
<ul>
<li>栈：就像装数据的桶或箱子，它是一种具有<strong>后进先出</strong>性质的数据结构。</li>
<li>堆：一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</li>
</ul>
<h3 id="12-程序的内存分配">1.2 程序的内存分配</h3>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>
1、<strong>栈区（stack）</strong> —— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>
2、<strong>堆区（heap）</strong> —— 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>
3、<strong>全局区（静态区）</strong>（static）—— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>
4、<strong>文字常量区</strong> —— 常量字符串就是放在这里的。程序结束后由系统释放。<br>
5、<strong>程序代码区</strong> —— 存放函数体的二进制代码。</p>
<p>可以根据以下代码进行理解：</p>
<pre><code>int  a=0;   全局初始化区    

char *p1;   全局未初始化区    
int  main()    
{    
  int  b; //栈    
  char  s[]=&quot;abc&quot;; //栈    
  char  *p2; //栈    
  char  *p3=&quot;123456&quot;; //123456/0在常量区，p3在栈上。    

  static int c =0；//全局（静态）初始化区    
  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2  = (char  *)malloc(20);       
  strcpy(p3,&quot;123456&quot;); //123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;  优化成一个地方。    
}    
</code></pre>
<h2 id="2-三种管理数据内存的方式">2. 三种管理数据内存的方式</h2>
<h3 id="21-自动存储">2.1 自动存储</h3>
<p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着他们在所属的函数被调用时自动产生，在该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域为包含它的代码块。</p>
<p>自动变量通常存储在栈中，即：执行该代码块时，其中变量依次加入栈中；而在离开代码块时，将按相反顺序释放这些变量——后进先出（LIFO）。因此，程序执行过程中，栈将不断的增大和缩小。</p>
<h3 id="22-静态存储">2.2 静态存储</h3>
<p>静态存储是整个程序执行期间都存在的存储方式。其数据位于静态存储区（静态区）。使得变量成为静态变量的方式有两种：1）在函数外部定义它；2）使用static关键字声明变量。</p>
<p>自动存储和静态存储的关键在于：其对于变量的寿命限制不同——变量可能存在于程序的的整个生命周期（静态变量）；也可能仅存在于特定函数被执行时（自动变量）。</p>
<p>例如：</p>
<pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
void display();
 
int main()
{
    display();
    display();
    display();
    display();
    display();
     return 0;
}
 
 
void display() {
    static int counter = 0;
    cout &lt;&lt; &quot;display function called &quot; &lt;&lt; ++counter &lt;&lt; &quot; times.&quot; &lt;&lt; endl;
}

/*
输出：
    display function called 1 times.
    display function called 2 times.
    display function called 3 times.
    display function called 4 times.
    display function called 5 times.
*/
</code></pre>
<p>上例说明：当我们在一个函数中声明一个static的变量的时候（即static 为function scope），那么这个静态变量的 lifetime将开始于函数第一次调用开始， 一直到这个Program 运行结束。即函数中的声明并初始化的static变量只执行一次， 无论在Program调用多少次， 都只执行一次， 并该变量保存在heap中。 发生修改就可以保存。</p>
<h3 id="23-动态存储">2.3 动态存储</h3>
<p><strong>new</strong>和<strong>delete</strong>运算符提供了一个比自动变量和静态变量更灵活的方法。其管理一个内存池，在C++中被称为自由存储空间（free store）或 堆（heap）。<strong>该内存池同用于静态变量和动态变量的内存是分开的</strong>。</p>
<p>new和delete使得程序员对变量寿命有更多控制权，甚至可以在一个函数中分配内存，而在另一个函数中释放。因此，数据的生命周期不完全受程序或函数的生存时间控制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络：TCP协议的三次握手 & 四次挥手]]></title>
        <id>https://mocuishle0.github.io/post/ji-suan-ji-wang-luo-tcp-xie-yi-de-san-ci-wo-shou-and-si-ci-hui-shou/</id>
        <link href="https://mocuishle0.github.io/post/ji-suan-ji-wang-luo-tcp-xie-yi-de-san-ci-wo-shou-and-si-ci-hui-shou/">
        </link>
        <updated>2020-06-07T01:38:50.000Z</updated>
        <summary type="html"><![CDATA[<p>上一次接触计算机网络相关知识还是本科阶段学习计网课程，此次为了准备相关面试，还是需要把这部分知识好好整理一下......</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一次接触计算机网络相关知识还是本科阶段学习计网课程，此次为了准备相关面试，还是需要把这部分知识好好整理一下......</p>
<!-- more -->
<p>计算机网络部分最容易考到的便是TCP协议的**“三次握手”<strong>和</strong>“四次挥手”**，在网上也看到了许多形象的解读，在此做一归纳：</p>
<h2 id="1-tcpip协议">1. TCP/IP协议</h2>
<p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，<strong>通常被认为是一个四层协议系统，与OSI的七层模型相对应</strong>。</p>
<p>HTTP（HyperText Transfer Protocol），超文本传输协议，是互联网上应用最广泛的一种网络协议，所有www文件都必须遵守的一个标准，是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。简而言之，<strong>HTTP协议就是基于TCP/IP协议模型来传输信息的</strong>。</p>
<p><strong>TCP/IP四层模型：</strong></p>
<ul>
<li><strong>链路层</strong>：也称作数<strong>据链路层或网络接口层</strong>（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
<li><strong>网络层</strong>： 也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
<li><strong>传输层</strong>：主要为两台主机上的应用程序提供端到端的通信。<strong>在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）</strong>。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。</li>
<li><strong>应用层</strong>：应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。</li>
</ul>
<h2 id="2-tcp三次握手">2. TCP三次握手</h2>
<p>先给一个更便于理解的示例：<br>
<img src="https://mocuishle0.github.io//post-images/1591494923826.webp" alt="" loading="lazy"></p>
<ul>
<li>客户端A：你好服务器，我是客户端A；</li>
<li>服务器B：你好客户端A，我是服务器B；</li>
<li>客户端A：你好，服务器B。</li>
</ul>
<p>官方描述：</p>
<ul>
<li><strong>第一次握手</strong>：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；【SYN：同步序列编号（Synchronize Sequence Numbers）】</li>
<li><strong>第二次握手</strong>：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。这样就保证了，每次传送数据都会准确到达目标设备了。</p>
<h2 id="3-tcp四次挥手">3. TCP四次挥手</h2>
<p>还是先给出一个更便于理解的示例：</p>
<ul>
<li>主动结束方：你好，我的数据发送完毕了，我要进入准备断开的状态了。（此时它虽然不再发送数据了，但是可以接受数据）</li>
<li>另一方：我知道了，我还没有发送完毕的，你等着吧。</li>
<li>另一方：我也发送完毕了，可以断开链接了。（此时它也进入准备断开的状态）</li>
<li>主动结束方：好的，那断开吧</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1591495364320.webp" alt="" loading="lazy"></figure>
<p>官方描述：</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h2 id="4-为什么tcp建立链接是三次关闭链接是四次呢">4. 为什么TCP建立链接是三次，关闭链接是四次呢？</h2>
<p>其实也不难理解，因为服务端的listen状态下的socket当收到SYN报文的建连请求后，<strong>它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送</strong>。但关闭连接时，当收到对方的FIN报文通知时，<strong>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</strong>。</p>
<p>通过TCP协议使得两台设备成功链接，并成功发送了数据，接下来，就需要服务器端来处理数据了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的emplace成员]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/">
        </link>
        <updated>2020-06-06T03:26:02.000Z</updated>
        <summary type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
<!-- more -->
<p>在右值引用和移动语义部分，其实我们的核心在于减少了程序运行中对变量的拷贝次数（这仅是个人直观的理解）。其实在C++11的容器中，还有一种优雅的方式可以达到这一目的。</p>
<h2 id="1-引例">1. 引例</h2>
<p>考虑下面的Rect类：</p>
<pre><code>struct Rect
{
    Rect(int l, int t, int r, int b)
        :left{l}, top{t}
        ,right{r}, bottom{b}
    {}
    int left;
    int top;
    int right;
    int bottom;
};
</code></pre>
<p>如果我们需要向容器添加Rect对象时，代码大致是这样的：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.push_front(Rect(10, 10, 20, 20));
</code></pre>
<p>在调用push_front时，首先构造一个临时的Rect对象传递给push_front方法，然后在push_front的内部，在复制一个Rect对象添加到容器中。全过程会发生一次创建动作和一次拷贝动作，才能将对象的内容添加到list当中去(其他容器同理)。</p>
<h2 id="2-emplace方法">2. emplace方法</h2>
<p>为了减少拷贝动作的次数，当然可以使用右值引用参数的成员函数。除此之外，C++11还提供了另一种方法：emplace成员。<strong>使用这个成员可以直接传递用于生成对象的参数，对象的创建过程交给容器去执行</strong>：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.emplace_front(10, 10, 20, 20);
</code></pre>
<p>用法非常简单，只要保证参数和元素构造函数的参数相同即可。除了emplace_front以外，C++11还提供了emplace和emplace_bak方法，分别对应insert和push_back方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：右值引用 与 移动语义]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/">
        </link>
        <updated>2020-06-06T00:59:33.000Z</updated>
        <summary type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
<!-- more -->
<p>实话实说，关于左值、右值的概念也是这次整理时才第一次接触到。所以就根据看到的相关资料做一个归纳。</p>
<h2 id="1-左值-右值">1. 左值 &amp; 右值</h2>
<p>在C++表达式的特性中有一个左值和右值的概念。如果一个表达式可以放在<strong>赋值语句</strong>的左侧，就称之为左值，如果不能放到表达式的左侧，就称之为右值。通俗的来讲，<strong>左值（lvalue）是一个表达式，它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址</strong>。如果一个表达式不是左值，那它就被定义为右值。</p>
<pre><code>//赋值操作需要左操作数是一个左值。var 是一个有内存位置的对象，因此它是左值.
int var;
var = 4;

4 = var;       // 错误！
(var + 1) = 4; // 错误！
</code></pre>
<p>在上面的例子中，常量 4 和表达式 var + 1 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p>
<p>不同的运算符对运算对象的要求各不相同，例如：</p>
<ul>
<li>赋值运算符的左侧要求是左值，得到的结果还是左值，因此我们可以继续对它赋值；</li>
<li>取地址符作用于左值运算对象，返回对象的指针为右值，因此取地址运算表达式只能位于赋值语句的右侧。</li>
</ul>
<h2 id="2-右值引用">2. 右值引用</h2>
<p>在介绍C++11 新引入的右值引用概念之前，我们先介绍一下一般的引用类型。需要注意的是，只有左值可以付给引用，如：</p>
<pre><code>int&amp; ref = 9;   //编译错误
</code></pre>
<p>我们只能这样做：</p>
<pre><code>    int l=9;
    int &amp;r=l;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //9 9

    r++;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //10 10
</code></pre>
<p>没有问题，l是左值，所以可以将引用类型的r绑定到l上，今后对r的操作就等同于对l的操作。</p>
<p>C++11引入了右值引用的概念，<strong>使得我们把引用与右值进行绑定。使用两个“取地址符号”</strong>：</p>
<pre><code>int&amp;&amp; rvalue_ref = 99;
</code></pre>
<p>下面的例子更有助于理解：</p>
<pre><code>#include &lt;iostream&gt;

void f(int&amp; i) { std::cout &lt;&lt; &quot;lvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }
void f(int&amp;&amp; i) { std::cout &lt;&lt; &quot;rvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }

int main()
{
    int i = 77;
    f(i);    // lvalue ref called
    f(99);   // rvalue ref called

    f(std::move(i));  
    
    /*std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对i赋值或销毁以外，不再使用它。*/

    return 0;
}
/*
    输出：
        lvalue ref: 77
        rvalue ref: 99
        lvalue ref: 77
*/
</code></pre>
<p>还存在更为隐晦的右值，如下例：</p>
<pre><code>#include &lt;iostream&gt;

int getValue ()     //getValue()是一个右值
{
    int ii = 10;
    return ii;
}

int main()
{
    const int&amp; val = getValue(); // OK
    int&amp; val = getValue(); // NOT OK

    const int&amp;&amp; val = getValue(); // OK
    int&amp;&amp; val = getValue(); //  OK
    return 0;
}

</code></pre>
<p>因此，对比以下代码，我们可以发现：</p>
<pre><code>void printReference (const int&amp; value)  //可以接受参数为左值，也可以接受右值。 
{
        cout &lt;&lt; value;
}

void printReference (int&amp;&amp; value)   //只能接受右值引用作为参数。
{
        cout &lt;&lt; value;
}
</code></pre>
<h2 id="3-移动语义">3. 移动语义</h2>
<p>了解了右值引用的基本概念后，其实我也很纠结：C++11引入这样一个令人头大的特征到底有什么用？在<a href="https://blog.csdn.net/craftsman1970/article/details/80397276">参考文献</a>中作者的解释其实是挺容易让我理解的：</p>
<h3 id="31-实例演示">3.1 实例演示</h3>
<p>在C++语言中，引用是作为一种高效，安全的传递数据的方式而存在的。除了一般的引用类型，还可以声明const引用。例如，我们有以下一个Image类：</p>
<pre><code>class Image
{
    private:
       int width = 0;
       int height = 0;
       char *data = nullptr;
public:

   Image(int w, int h): width(w), height(h){
       data = new char[getSize()];
    }

   int getSize(){
       return width * height;
    }

   virtual ~Image(){
        if (data != nullptr){
            delete data;
            data = nullptr;
            width = 0;
            height = 0;        
        }  
    }
}
</code></pre>
<p>上面只是这个类的雏形，只有构造函数，析构函数和取得数据大小的功能。接下来添加比较两个Image是否相同的函数。最简单的形式大致如下。</p>
<pre><code>bool isSame(Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        return (memcmp(data,img.data,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里使用引用类型的参数，避免了没有必要的拷贝动作。当然我们还可以做得更好：<strong>由于比较函数没有必要也不应该对比较对象的内容进行修改，所以还可用下面的形式进行承诺</strong>：</p>
<pre><code>bool isSame(const Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        char* in = static_cast&lt;char*&gt;(img.data);
        return (memcmp(data,in,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里，<strong>通过在参数前面增加const修饰符，向isSame方法的调用者保证，不会修改img的内容</strong>。</p>
<hr>
<p>到此为止都是我们所熟悉的内容。然而，如果我们希望继续添加将一个Image的一部分merge到另一个Image上的方法，函数的内容大致如下(这里忽略处理的细节)：</p>
<pre><code>void merge(Image&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>类似的操作在处理在输入对象时一般有两种处理方式。有时希望只是参照而不破坏输入数据，这时可以使用前面讲到的为参数增加const修饰符的方式来承诺；有时为了提高效率或者其他的原因希望可以<strong>接管输入的数据，就像上面代码的状态</strong>。这时的行为更像是数据移动。对于第二种方式，如果仅仅定义一般的引用类型，<strong>利用者根本没有办法通过方法声明来确定这个操作是否会接管参数中的数据。这种不确定性会造成很大的麻烦</strong>。解决这个问题的方法就是利用右值引用：</p>
<pre><code>void merge(Image&amp;&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>我们将参数声明为右值引用，要求像一个临时变量一样任性地使用数据。使用这个函数的方法如下：</p>
<pre><code>Image img1(100, 100);
Image img2(100, 200);
img1.merge(std::move(img2));
</code></pre>
<p>注意代码中的std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对img2赋值或销毁以外，不再使用它。C++11通过使用右值引用提供了一种接管数据的标准方法。</p>
<h3 id="32-移动语义的功能">3.2 移动语义的功能</h3>
<p>当一个函数的参数<strong>按值传递</strong>时，这就会进行<strong>拷贝</strong>。当然，编译器懂得如何去拷贝。 而对于我们自定义的类型，我们也许需要提供拷贝构造函数。但是不得不说，拷贝的代价是昂贵的。所以我们需要寻找一个避免不必要拷贝的方法，即C++11提供的移动语义。</p>
<p>实际上，我们在第2部分介绍的右值引用，其主要目的是用于<strong>创建移动构造函数</strong>和<strong>移动赋值运算</strong>。</p>
<p>移动构造函数类似于拷贝构造函数，把类的实例对象作为参数，并创建一个新的实例对象。但是，移动构造函数可以避免内存的重新分配，因为我们知道右值引用提供了一个暂时的对象，而不是进行copy，所以我们可以进行移动。换言之，<strong>在涉及到关于临时对象时，右值引用和移动语义允许我们避免不必要的拷贝</strong>。我们不想拷贝将要消失的临时对象，所以这个临时对象的资源可以被我们用作于其他的对象。<strong>右值就是典型的临时变量，并且他们可以被修改。如果我们知道一个函数的参数是一个右值，我们可以把它当做一个临时存储。这就意味着我们要移动而不是拷贝右值参数的内容</strong>。这就会节省很多的空间。</p>
<p>更详细的解释可参考：<a href="https://www.kancloud.cn/wangshubo1989/new-characteristics/99718">文献</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：array容器]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/">
        </link>
        <updated>2020-06-06T00:29:41.000Z</updated>
        <summary type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
]]></summary>
        <content type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
<!-- more -->
<p>就我个人而言，原生内置数组时常感觉用起来并不十分顺手。一是大小没有管理，二是越界操作没有检查。虽然C/C++也提供了一些解决办法，但总是不够完美。例如下面的代码：</p>
<pre><code>int ary[5];
memset(ary, 0, sizeof(ary));
unsigned int i = 0;
while(i&lt;sizeof(ary)/sizeof(ary[0])){
    ary[i] = i;
    i++;
}
</code></pre>
<p>C++11后，标准库引入了更现代化的数组std::array。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array<strong>不支持添加和删除元素以及改变容器大小的操作</strong>。与内置数组一样，标准库array的大小也是类型的一部分。<strong>当定义一个array时，除了指定元素类型，还要指定容器大小</strong>（array&lt;T,N&gt; 模板定义了一种相当于标准数组的容器类型。它是一个<strong>有 N 个 T 类型元素的固定序列</strong>）。为了使用array类型，我们必须同时指定元素类型和大小。array仅仅是为普通数组添加了一些成员或全局函数，这使得数组能够被当成标准容器来使用。array不能被动态地扩展或压缩。</p>
<p>和标准数组相比，array 容器的额外开销很小，但提供了两个优点：<strong>1）如果使用 at()，当用一个非法的索引访问数组元素时，能够被检测到，因为容器知道它有多少个元素；2）这也就意味着数组容器可以作为参数传给函数，而不再需要单独去指定数组元素的个数。</strong></p>
<p>使用 array 容器类型时，需要在源文件中包含头文件 array。下面展示了如何创建具有 10 个 double 型元素的 array&lt;&gt;，该实例定义了一个 array 容器，却没有为元素指定初始值，那么元素就不会被初始化：</p>
<pre><code>std::array&lt;double,10&gt; arr;
</code></pre>
<p>但是可以如下所示，将它们初始化为 0 或者和默认元素类型等效的值。使用下面语句初始化后，容器中所有的元素都会变为 0.0。</p>
<pre><code>std::array&lt;double,10&gt; arr{};
</code></pre>
<p>当然，当创建 array 容器的实例时，要像创建常规数组那样，对元素进行初始化：</p>
<pre><code>std::array&lt;double, 10&gt; arr {0.5, 1.0, 1.5, 2.0};
</code></pre>
<p>初始化器列表中的 4 个值用于初始化前 4 个元素，其余的元素都将为 0。</p>
<p>回到我们最初的原生内置数组代码，我们可以利用array编写如下代码：</p>
<pre><code>std::array&lt;int, 5&gt; c11ary;
c11ary.fill(0);
unsigned int i = 0;
while(i&lt;c11ary.size()){
    c11ary.at(i) = i;
    i++;
}
</code></pre>
<p>这段代码中:</p>
<ul>
<li>使用fill方法实现了数据填充。</li>
<li>使用size方法取得数组的大小。</li>
<li>虽然at(i)方法实现带有越界检查的读写。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：返回类型后置]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/">
        </link>
        <updated>2020-06-05T07:46:07.000Z</updated>
        <summary type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
]]></summary>
        <content type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
<!-- more -->
<p>除了构造函数和析构函数以外，函数声明都需要明确函数的返回类型，在传统的C或者C++中，函数声明大致是这个样子：</p>
<pre><code>int getSum(int a, int b);
</code></pre>
<p>第一个int就是函数的返回类型，它表明函数的返回值类型为整数。在新的C++11以后，我们也可以这样声明：</p>
<pre><code>auto getSum(int a, int b)-&gt;int;
</code></pre>
<p>在原来放返回值类型的位置写auto，在函数声明结束以后接一个'-&gt;'再跟着写函数的返回值类型。两种方式的效果是一样的。</p>
<hr>
<p><strong>更优雅的用法：</strong></p>
<p>在介绍返回类型后置之前，我们先来再谈一组令人头大的概念：<strong>数组指针</strong>和<strong>指针数组</strong>......（回想起了被指针常量和常量指针支配的恐惧 -_-）</p>
<ul>
<li><strong>数组指针</strong>：可以理解为**“数组的指针”<strong>，即首先这个变量是一个</strong>指针**，其次，“数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
<ul>
<li>e.g：*<em>char (<em>pa)[4];</em></em></li>
<li>pa是一个指针指向一个char [4]的数组，每个数组元素是一个char类型的变量，所以我们不妨可以写成：char[4] (*pa);这样就可以直观的看出pa的指向的类型。（不过在编辑器中不要这么写，因为编译器根本不认识，这样写只是帮助我们理解。）</li>
</ul>
</li>
<li><strong>指针数组</strong>：可以理解为**“指针的数组”<strong>，首先这个变量是一个</strong>数组**，其次，“指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。
<ul>
<li>e.g：*<em>char <em>arr[4] = {&quot;hello&quot;, &quot;world&quot;, &quot;shannxi&quot;, &quot;xian&quot;};</em></em></li>
<li>arr就是定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。</li>
</ul>
</li>
</ul>
<p>P.s：<strong>指针数组和数组指针的形成的根本原因就是运算符的优先级问题</strong>，所以定义变量是一定要注意这个问题，否则定义变量会有根本性差别！</p>
<p>在明白了<strong>数组指针</strong>和<strong>指针数组</strong>的概念后，我们来聊聊返回类型后置的一种优雅的用法：</p>
<p>一般情况下，当函数要返回多个数据时，会选择将数据封装在类（或结构体）中返回，或者直接返回一个指针。这两种方式要么麻烦，要么没有办法取得数据的数量。其实我们真正的需求就是返回一个数组（可以计算维度的）指针。这种方法是存在的：</p>
<blockquote>
<p>e.g:int (*getResultArray(int mode))[10];</p>
</blockquote>
<p>结合数组指针和指针数组的定义，上面的是数组指针还是指针数组呢？应该是<strong>数组指针</strong>。通过上面的形式，声明了一个返回包含10个整数的数组的指针。对于这样一个指针，我们可以像数组一样使用：</p>
<pre><code>auto arr = getResultArray(1);
cout &lt;&lt; sizeof(*arr)/sizeof(**arr) &lt;&lt; endl; //可以正确计算维度。
</code></pre>
<p>我们其实也可以这样做：</p>
<pre><code>typedef int arr10[10];
arr10* getResultArray(int mode)
</code></pre>
<p>C++11增加了返回类型后置以后，我们有了新的选择：</p>
<pre><code>auto getResultArray(int mode)-&gt;int(*)[10]；
</code></pre>
<p>比第一种形式容易理解很多。也不需要自定义类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的cbegin和cend函数 ]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/">
        </link>
        <updated>2020-06-05T03:41:53.000Z</updated>
        <summary type="html"><![CDATA[<p>小众的常量迭代器</p>
]]></summary>
        <content type="html"><![CDATA[<p>小众的常量迭代器</p>
<!-- more -->
<p>这个新特征其实是偶尔在别人的总结中看到的，但觉得确实很有趣，就做个记录：</p>
<h2 id="1-需求">1. 需求</h2>
<p>我们一般在使用STL容器时，下面代码是非常常见的：</p>
<pre><code>int sum = 0;
vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator it = v.begin();
while(it != v.end()){
       sum += *it;
       it++;
 }
</code></pre>
<p>但是，如果我们一旦定义容器为常量，就必须注意迭代器也需要声明为常量：</p>
<pre><code>int sum = 0;

//编译错误：原因是定义的vector是const类型，所以迭代器必须也是const类型
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
 }

//正确写法：
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::const_iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
}
</code></pre>
<p>这显然很麻烦，一个简单的方法是直接使用auto来自动推断迭代器类型（想必大家都更倾向于这样，毕竟...有了auto还要啥自行车）：</p>
<pre><code>auto ait = cv.begin();
while(ait != cv.end()){ 
       sum += *ait;
       ait++;
 }
</code></pre>
<h2 id="2-优势">2. 优势</h2>
<p>但我们也不难想到存在这样一种情形：<strong>数据本身不是const类型，但是从设计的角度来讲有些处理不应该修改该数据</strong>。这时也应该要求const类型的迭代器，以避免数据被意外修改。所以，C++11为此提供了cbegin和cend方法。</p>
<pre><code>vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
auto ait = v.cbegin();
while(ait != v.cend()){
           sum += *ait;
           *ait = sum;  //编译错误
           ait++;
}
</code></pre>
<p>cbegin()/cend()决定了返回的迭代器类型为const。这时即使vector的类型不是const，也可以防止对该数据的误操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：常量表达式]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-chang-liang-biao-da-shi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-chang-liang-biao-da-shi/">
        </link>
        <updated>2020-06-05T02:05:16.000Z</updated>
        <summary type="html"><![CDATA[<p>常量+指针......可真是太难了</p>
]]></summary>
        <content type="html"><![CDATA[<p>常量+指针......可真是太难了</p>
<!-- more -->
<p>总体而言，常量本身并不难理解：使用<strong>const</strong>关键词限定的量被认为是常量；常量一旦初始化便不允许修改。然而，C++中最让人头疼的概念莫过于指针了，因此常量一旦结合指针......极致的快乐就来了。单单脑补一下这两个名词：指针常量、常量指针......就够头大了。因此，在正式开始之前，我还是得复习一下C++中指针的概念。</p>
<h2 id="1-指针">1. 指针</h2>
<p>首先，所谓指针，其本质仍然是一个变量，但其值为另一个变量的地址，即，内存位置的直接地址。<br>
提到指针，其实理解的关键在于理解两个运算符——<strong>“*”和“&amp;”</strong>：</p>
<ul>
<li>** “*”**：被称为间接值或解除引用运算符，将其用于指针，<strong>可得到该地址处所存储的值</strong>。（由于指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的值就是一个变量的地址，因此，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">*p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord mathdefault">p</span></span></span></span>就是该指针所指向变量的值）。</li>
<li><strong>“&amp;”</strong>：地址运算符，用于访问变量的地址。</li>
</ul>
<p>所以，根据指针的定义以及“*”和“&amp;”的用法，我们可以更好地理解C++中指针的声明和初始化：</p>
<pre><code>//初始化方式1：先声明，后初始化——更好理解
int a = 25;
int *ptr_a;
ptr_a = &amp;a;

//初始化方式2：声明同时初始化——更常用，也更安全
int b = 20;
int *ptr_b = &amp;b;        /P.s:是将ptr_b初始化，即：将ptr_b（而不是*ptr_b）的值设置为&amp;b。

//初始化方式3：数组初始化
int c[10];
int *ptr_c1 = c;  
int *ptr_c2 = &amp;c[0];
</code></pre>
<p>为了加深理解，再给几个例子，你品，你细品：</p>
<pre><code>//错误示例：p仅声明了而没有初始化，所以p所指向的内存位置是随机的。
int  *p;
*p = 7;

//正确示例：
int k = 1, m = 3;

int *p;
p = &amp;k; //给p赋值
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

*p = 7; //给p所指向的内存赋值，即k= 7
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

p = &amp;m;
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

/*
最终输出：
0x7ffee6e7974c 0x7ffee6e7974c 0x7ffee6e79748
1 1 3
0x7ffee6e7974c 0x7ffee6e7974c 0x7ffee6e79748
7 7 3
0x7ffee6e7974c 0x7ffee6e79748 0x7ffee6e79748
7 3 3
*/
</code></pre>
<h2 id="2-指针常量-常量指针">2. “指针常量” &amp; “常量指针”</h2>
<p>如果，到这里还顶得住，那我们来谈谈一开始我们说的“指针常量”和“常量指针”：<br>
这两个概念其实从本科一直到研究生我都一直在“懂了”-“晕了”之间反复横跳～直到在<a href="https://www.zhihu.com/question/19829354">知乎</a>看到一个非常有趣的解释，突然之间———我觉得我又可以了：<br>
其实，常量和指针的结合方式共有6种：<br>
①const int p;<br>
②const int* p;<br>
③int const* p<br>
④int * const p;<br>
⑤const int * const p;<br>
⑥int const * const p;</p>
<p>①其实没什么好说的，平平无奇的一个常量整数。然而，后面几个，emmm...老千层饼了，直接劝退。<br>
先别怕，这里其实有一套实用的技巧：</p>
<ul>
<li>从右往左读；</li>
<li>遇到p就替换成“p is a ”；</li>
<li>遇到*就替换成“point to”。</li>
</ul>
<p>例如：<br>
②读作：“p is a point to int const.”--这说明p是一个指向整型常量的指针。<br>
③读作：“p is a point to const int.” --意思跟②相同。<br>
④读作：“p is a const point to int.”--p是一个常量指针，指向整型。<br>
⑤读作：“p is a const point to int const.”<br>
⑥读作：“p is a const point to const int.”--⑤和⑥的意思相同，p都是常量指针，指向整型常量。<br>
这里再说明一下：如果p是一个指针，指向常量，说明指向的常量的值是不能更改的；如果p是一个常量指针，指向整型，说明p的值（存的地址）是不能更改的（老千层饼*2）。可以再给一个例子：</p>
<pre><code>const double pi = 3.14;
const double  *cptr = &amp;pi;    //指向常量的指针
*cptr = 4;            //cptr存的是常量pi的地址，所以*cptr常量pi的地址所指向的值。因此，该语句其实是企图更改常量的值——编译错误


double var1 = 45, var2=50;
double *const  pvar = &amp;var1;  //常量指针，指向double变量。
*pvar = 40;       //与上一个例子相同，这里是企图改变var1的值，而不是改变常量指针存储的值——正确

pvar = &amp;var2;   //该语句实质是想改变常量指针里面存储的地址——编译错误
</code></pre>
<p>到这里，应该说清楚了吧......</p>
<h2 id="3-常量表达式">3. 常量表达式</h2>
<h3 id="31-什么是常量表达式">3.1 什么是常量表达式</h3>
<p>常量表达式是指值不会改变并且在<strong>编译过程</strong>就能够得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。如下：</p>
<pre><code>const int max_num = 20;           // max_num是常量表达式
const int limit = max_num + 1;    // limit 是常量表达式
int staff_size = 2;               // staff_size 不是常量表达式，因为staff_size没有用const修饰
const int zs = get_size();        // sz 不是常量表达式，虽然sz是个常量，但它的值在运行时才能确定
</code></pre>
<p>可见：<strong>一个对象（或表达式）是不是常量表达式由它的数据类型（是否const）和初始值共同决定。</strong></p>
<h3 id="32-constexprconst-expression">3.2 constexpr(const expression)：</h3>
<p>const可以用来修饰常量，可是只有当其初始值是个常量表达式时，const修饰的对象才是个常量表达式。一般来说，在日益复杂的系统中确定变量的初始值到底是不是常量表达式并不是一件容易的事。为了解决这个问题C++11允许将变量声明为<strong>constexpr</strong>类型以便由编译器验证变量的值是否是一个常量表达式。一般而言，<strong>如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。constexpr 变量在定义时必须初始化</strong>。</p>
<pre><code>constexpr int mf = 20;		// mf是常量表达式
constexpr int limit = mf + 1;	// limit 是常量表达式
constexpr int sz = get_sz();	// 只有当 get_sz() 是一个 constexpr 函数时才是一条正确的声明语句
</code></pre>
<h3 id="33-指针和constexpr">3.3 指针和constexpr</h3>
<p>从上面的介绍不难看出，变量声明为constexpr类型，就意味着<strong>一方面变量本身是常量，也意味着它必须用常量表达式来初始化</strong>。所以，当 constexpr 修饰指针时，constexpr 仅对指针有效，与指针所指的对象无关：</p>
<pre><code>const int *p = nullptr;		// p 是指向常量的指针
constexpr int *q = nullptr;	// q 是常指针，constexpr 仅对指针有效
</code></pre>
<p>当然，const 和 constptr 可以一起来修饰一个指针，用于表明指向常量的常指针:</p>
<pre><code>constexpr const int *p = &amp;i;	
// 指向常量的常指针，注意 &amp;i 必须是常量表达式，i可以是全局变量或静态变量等等。。这些变量的地址在编译时就确定了
</code></pre>
<h3 id="34-constexpr函数">3.4 constexpr函数</h3>
<p>除了能用常量表达式初始化constexpr变量以外，还可以使用constexpr函数。它是指<strong>能用于常量表达式的函数，也就是说它的计算结果可以在编译时确定</strong>。定义的方法就是在<strong>返回值类型前加constexpr关键字</strong>。但是为了保证计算结果可以在编译是确定，必须满足以下条件：</p>
<ul>
<li>返回值和形参必须都是字面值类型。</li>
<li>函数中只能有一条return语句。</li>
</ul>
<pre><code>constexpr long long factorial(int n){

   return n &lt;= 1? 1 : (n * factorial(n - 1));

}

constexpr long long f18 = factorial(20);
</code></pre>
<h3 id="35-总结">3.5 总结</h3>
<p>constexpr可以：</p>
<ul>
<li>加强初始值的检查</li>
<li>计算的时机从运行时提前到编译时，比宏定义效率更高。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特性：列表初始化]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-xing-lie-biao-chu-shi-hua/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-xing-lie-biao-chu-shi-hua/">
        </link>
        <updated>2020-06-04T09:13:03.000Z</updated>
        <summary type="html"><![CDATA[<p>优雅的初始化方式</p>
]]></summary>
        <content type="html"><![CDATA[<p>优雅的初始化方式</p>
<!-- more -->
<p>回想一下，之前C或者C++在初始化数组时，可以使用下面的花括号加初始值的形式：</p>
<pre><code>int int_array[] = {1, 2, 3, 4, 5};
</code></pre>
<p>这对于常使用C++的程序员而言，是一种司空见惯的写法。然而，这种方法的运用范围很窄，许多场景都用不了。最典型的例子莫过于vector：可以像数组一样使用，可以自己管理数据长度，还提供各种操作数组的方法。声明的方法也很简单：</p>
<pre><code>vector&lt;int&gt; int_vector;
</code></pre>
<p>但是有一个问题，当需要指定元素初始化vector时就不那么方便了，传统的初始化方法有以下几类：</p>
<pre><code>//方法1:逐一压入
int_vector.push_back(5);
int_vector.push_back(4);
int_vector.push_back(3);
int_vector.push_back(2);
int_vector.push_back(1);
//方法2:统一赋值——int_vector共有10个元素，每个元素都是8
vector&lt;int&gt; int_vector(10,8)；
</code></pre>
<h2 id="列表初始化">列表初始化</h2>
<p>C++11中扩展了使用<strong>花括号</strong>初始化变量的应用范围，称这种初始化方式为列表初始化。例如，可以像下面这样初始化vector、list、map:</p>
<pre><code>vector&lt;int&gt; int_vector = {5, 4, 3, 2, 1};
list&lt;int&gt; int_list = {5, 4, 3, 2, 1};
map&lt;int, const char*&gt; id2Name = {{1,&quot;Zhang&quot;},{2, &quot;Wang&quot;},{3, &quot;Li&quot;}};
</code></pre>
<p>更简单的还有以下写法：</p>
<pre><code>vector&lt;int&gt; int_vector{5, 4, 3, 2, 1};

list&lt;int&gt; int_list {5, 4, 3, 2, 1};

map&lt;int, const char*&gt; id2Name{{1,&quot;Zhang&quot;},{2, &quot;Wang&quot;},{3, &quot;Li&quot;}};
</code></pre>
<p>舒服了～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：基于范围的for循环]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-ji-yu-fan-wei-de-for-xun-huan/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-ji-yu-fan-wei-de-for-xun-huan/">
        </link>
        <updated>2020-06-04T08:13:10.000Z</updated>
        <summary type="html"><![CDATA[<p>像python一样，优雅地简化对数组、容器的遍历代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>像python一样，优雅地简化对数组、容器的遍历代码。</p>
<!-- more -->
<p>其实很多时候还是很羡慕python中for循环的写法的，直到发现...原来C++11原来也有这么优雅的循环写法，真香！<br>
为了在遍历容器时支持“foreach”用法，C++11扩展了for语句的语法。用这个新的写法，<strong>可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型</strong>。 如果你只是想对集合或数组的每个元素做一些操作，而不关心下标、迭代器位置或者元素个数，那么这种foreach的for循环将会非常有用。</p>
<h2 id="1-基于范围的for循环">1. 基于范围的for循环</h2>
<p>循环最常见的的场景就是对数据集合的每一个元素进行某种操作。C++11之前，大致是这样的程序：</p>
<pre><code>int a[] = {1, 2, 3, 4};

int sum = 0;

for(int i = 0 ; i &lt; sizeof(a)/sizeof(a[0]); ++i)｛

        sum += a[i];

｝

vector&lt;int&gt; v{1, 2, 3,4};

int sum = 0;

for(auto it = v.begin(); it != v.end(); it++){

    sum += *it;

}
</code></pre>
<p>而在C++11 引入基于范围的for循环后，循环可以优雅地写成下面这样：</p>
<pre><code>int array[]{1, 2, 3, 4};

int sum = 0;

 for(int a : array){

     sum += a;

}

vector&lt;int&gt; vect{1, 2, 3, 4};

int sum = 0;

for(int v: vect){

    sum += v;

}
</code></pre>
<p>for(int v : vect)可以理解为“对于vect中的每一个v”。</p>
<h2 id="2-应用条件">2. 应用条件</h2>
<p>正如之前所说，数据v被范围for遍历的条件是，该<strong>数据支持v.begin()/v.end()或者是begin(v)/end(v)并返回一个迭代器</strong>。STL中的容器都满足上述条件。对于内置类型的数组来讲C++编译器提供了等同于上述接口的机制，因此也可以在范围for中使用。</p>
<h2 id="3-完整示例">3. 完整示例</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main() {
    std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5};
 
    for (const int&amp; i : v) // 以 const 引用访问
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto i : v) // 以值访问，i 的类型是 int
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto&amp; i : v) // 以引用访问，i 的类型是 int&amp;
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (int n : {0, 1, 2, 3, 4, 5}) // 初始化器可以是花括号初始化器列表
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    int a[] = {0, 1, 2, 3, 4, 5};
    for (int n : a) // 初始化器可以是数组
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (int n : a)  
        std::cout &lt;&lt; 1 &lt;&lt; ' '; // 不必使用循环变量
    std::cout &lt;&lt; '\n';
 
}

//输出为
// 0 1 2 3 4 5
// 0 1 2 3 4 5
// 0 1 2 3 4 
// 0 1 2 3 4 5
// 0 1 2 3 4 5
// 1 1 1 1 1 1
</code></pre>
]]></content>
    </entry>
</feed>