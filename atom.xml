<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mocuishle0.github.io/</id>
    <title>MoCuishle</title>
    <updated>2020-06-06T10:42:45.556Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mocuishle0.github.io/"/>
    <link rel="self" href="https://mocuishle0.github.io/atom.xml"/>
    <subtitle>我拥有的都是侥幸，
我失去的都是人生。</subtitle>
    <logo>https://mocuishle0.github.io/images/avatar.png</logo>
    <icon>https://mocuishle0.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MoCuishle</rights>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的emplace成员]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/">
        </link>
        <updated>2020-06-06T03:26:02.000Z</updated>
        <summary type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
<!-- more -->
<p>在右值引用和移动语义部分，其实我们的核心在于减少了程序运行中对变量的拷贝次数（这仅是个人直观的理解）。其实在C++11的容器中，还有一种优雅的方式可以达到这一目的。</p>
<h2 id="1-引例">1. 引例</h2>
<p>考虑下面的Rect类：</p>
<pre><code>struct Rect
{
    Rect(int l, int t, int r, int b)
        :left{l}, top{t}
        ,right{r}, bottom{b}
    {}
    int left;
    int top;
    int right;
    int bottom;
};
</code></pre>
<p>如果我们需要向容器添加Rect对象时，代码大致是这样的：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.push_front(Rect(10, 10, 20, 20));
</code></pre>
<p>在调用push_front时，首先构造一个临时的Rect对象传递给push_front方法，然后在push_front的内部，在复制一个Rect对象添加到容器中。全过程会发生一次创建动作和一次拷贝动作，才能将对象的内容添加到list当中去(其他容器同理)。</p>
<h2 id="2-emplace方法">2. emplace方法</h2>
<p>为了减少拷贝动作的次数，当然可以使用右值引用参数的成员函数。除此之外，C++11还提供了另一种方法：emplace成员。<strong>使用这个成员可以直接传递用于生成对象的参数，对象的创建过程交给容器去执行</strong>：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.emplace_front(10, 10, 20, 20);
</code></pre>
<p>用法非常简单，只要保证参数和元素构造函数的参数相同即可。除了emplace_front以外，C++11还提供了emplace和emplace_bak方法，分别对应insert和push_back方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：右值引用 与 移动语义]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/">
        </link>
        <updated>2020-06-06T00:59:33.000Z</updated>
        <summary type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
<!-- more -->
<p>实话实说，关于左值、右值的概念也是这次整理时才第一次接触到。所以就根据看到的相关资料做一个归纳。</p>
<h2 id="1-左值-右值">1. 左值 &amp; 右值</h2>
<p>在C++表达式的特性中有一个左值和右值的概念。如果一个表达式可以放在<strong>赋值语句</strong>的左侧，就称之为左值，如果不能放到表达式的左侧，就称之为右值。通俗的来讲，<strong>左值（lvalue）是一个表达式，它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址</strong>。如果一个表达式不是左值，那它就被定义为右值。</p>
<pre><code>//赋值操作需要左操作数是一个左值。var 是一个有内存位置的对象，因此它是左值.
int var;
var = 4;

4 = var;       // 错误！
(var + 1) = 4; // 错误！
</code></pre>
<p>在上面的例子中，常量 4 和表达式 var + 1 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p>
<p>不同的运算符对运算对象的要求各不相同，例如：</p>
<ul>
<li>赋值运算符的左侧要求是左值，得到的结果还是左值，因此我们可以继续对它赋值；</li>
<li>取地址符作用于左值运算对象，返回对象的指针为右值，因此取地址运算表达式只能位于赋值语句的右侧。</li>
</ul>
<h2 id="2-右值引用">2. 右值引用</h2>
<p>在介绍C++11 新引入的右值引用概念之前，我们先介绍一下一般的引用类型。需要注意的是，只有左值可以付给引用，如：</p>
<pre><code>int&amp; ref = 9;   //编译错误
</code></pre>
<p>我们只能这样做：</p>
<pre><code>    int l=9;
    int &amp;r=l;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //9 9

    r++;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //10 10
</code></pre>
<p>没有问题，l是左值，所以可以将引用类型的r绑定到l上，今后对r的操作就等同于对l的操作。</p>
<p>C++11引入了右值引用的概念，<strong>使得我们把引用与右值进行绑定。使用两个“取地址符号”</strong>：</p>
<pre><code>int&amp;&amp; rvalue_ref = 99;
</code></pre>
<p>下面的例子更有助于理解：</p>
<pre><code>#include &lt;iostream&gt;

void f(int&amp; i) { std::cout &lt;&lt; &quot;lvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }
void f(int&amp;&amp; i) { std::cout &lt;&lt; &quot;rvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }

int main()
{
    int i = 77;
    f(i);    // lvalue ref called
    f(99);   // rvalue ref called

    f(std::move(i));  
    
    /*std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对i赋值或销毁以外，不再使用它。*/

    return 0;
}
/*
    输出：
        lvalue ref: 77
        rvalue ref: 99
        lvalue ref: 77
*/
</code></pre>
<p>还存在更为隐晦的右值，如下例：</p>
<pre><code>#include &lt;iostream&gt;

int getValue ()     //getValue()是一个右值
{
    int ii = 10;
    return ii;
}

int main()
{
    const int&amp; val = getValue(); // OK
    int&amp; val = getValue(); // NOT OK

    const int&amp;&amp; val = getValue(); // OK
    int&amp;&amp; val = getValue(); //  OK
    return 0;
}

</code></pre>
<p>因此，对比以下代码，我们可以发现：</p>
<pre><code>void printReference (const int&amp; value)  //可以接受参数为左值，也可以接受右值。 
{
        cout &lt;&lt; value;
}

void printReference (int&amp;&amp; value)   //只能接受右值引用作为参数。
{
        cout &lt;&lt; value;
}
</code></pre>
<h2 id="3-移动语义">3. 移动语义</h2>
<p>了解了右值引用的基本概念后，其实我也很纠结：C++11引入这样一个令人头大的特征到底有什么用？在<a href="https://blog.csdn.net/craftsman1970/article/details/80397276">参考文献</a>中作者的解释其实是挺容易让我理解的：</p>
<h3 id="31-实例演示">3.1 实例演示</h3>
<p>在C++语言中，引用是作为一种高效，安全的传递数据的方式而存在的。除了一般的引用类型，还可以声明const引用。例如，我们有以下一个Image类：</p>
<pre><code>class Image
{
    private:
       int width = 0;
       int height = 0;
       char *data = nullptr;
public:

   Image(int w, int h): width(w), height(h){
       data = new char[getSize()];
    }

   int getSize(){
       return width * height;
    }

   virtual ~Image(){
        if (data != nullptr){
            delete data;
            data = nullptr;
            width = 0;
            height = 0;        
        }  
    }
}
</code></pre>
<p>上面只是这个类的雏形，只有构造函数，析构函数和取得数据大小的功能。接下来添加比较两个Image是否相同的函数。最简单的形式大致如下。</p>
<pre><code>bool isSame(Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        return (memcmp(data,img.data,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里使用引用类型的参数，避免了没有必要的拷贝动作。当然我们还可以做得更好：<strong>由于比较函数没有必要也不应该对比较对象的内容进行修改，所以还可用下面的形式进行承诺</strong>：</p>
<pre><code>bool isSame(const Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        char* in = static_cast&lt;char*&gt;(img.data);
        return (memcmp(data,in,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里，<strong>通过在参数前面增加const修饰符，向isSame方法的调用者保证，不会修改img的内容</strong>。</p>
<hr>
<p>到此为止都是我们所熟悉的内容。然而，如果我们希望继续添加将一个Image的一部分merge到另一个Image上的方法，函数的内容大致如下(这里忽略处理的细节)：</p>
<pre><code>void merge(Image&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>类似的操作在处理在输入对象时一般有两种处理方式。有时希望只是参照而不破坏输入数据，这时可以使用前面讲到的为参数增加const修饰符的方式来承诺；有时为了提高效率或者其他的原因希望可以<strong>接管输入的数据，就像上面代码的状态</strong>。这时的行为更像是数据移动。对于第二种方式，如果仅仅定义一般的引用类型，<strong>利用者根本没有办法通过方法声明来确定这个操作是否会接管参数中的数据。这种不确定性会造成很大的麻烦</strong>。解决这个问题的方法就是利用右值引用：</p>
<pre><code>void merge(Image&amp;&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>我们将参数声明为右值引用，要求像一个临时变量一样任性地使用数据。使用这个函数的方法如下：</p>
<pre><code>Image img1(100, 100);
Image img2(100, 200);
img1.merge(std::move(img2));
</code></pre>
<p>注意代码中的std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对img2赋值或销毁以外，不再使用它。C++11通过使用右值引用提供了一种接管数据的标准方法。</p>
<h3 id="32-移动语义的功能">3.2 移动语义的功能</h3>
<p>当一个函数的参数<strong>按值传递</strong>时，这就会进行<strong>拷贝</strong>。当然，编译器懂得如何去拷贝。 而对于我们自定义的类型，我们也许需要提供拷贝构造函数。但是不得不说，拷贝的代价是昂贵的。所以我们需要寻找一个避免不必要拷贝的方法，即C++11提供的移动语义。</p>
<p>实际上，我们在第2部分介绍的右值引用，其主要目的是用于<strong>创建移动构造函数</strong>和<strong>移动赋值运算</strong>。</p>
<p>移动构造函数类似于拷贝构造函数，把类的实例对象作为参数，并创建一个新的实例对象。但是，移动构造函数可以避免内存的重新分配，因为我们知道右值引用提供了一个暂时的对象，而不是进行copy，所以我们可以进行移动。换言之，<strong>在涉及到关于临时对象时，右值引用和移动语义允许我们避免不必要的拷贝</strong>。我们不想拷贝将要消失的临时对象，所以这个临时对象的资源可以被我们用作于其他的对象。<strong>右值就是典型的临时变量，并且他们可以被修改。如果我们知道一个函数的参数是一个右值，我们可以把它当做一个临时存储。这就意味着我们要移动而不是拷贝右值参数的内容</strong>。这就会节省很多的空间。</p>
<p>更详细的解释可参考：<a href="https://www.kancloud.cn/wangshubo1989/new-characteristics/99718">文献</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：array容器]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/">
        </link>
        <updated>2020-06-06T00:29:41.000Z</updated>
        <summary type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
]]></summary>
        <content type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
<!-- more -->
<p>就我个人而言，原生内置数组时常感觉用起来并不十分顺手。一是大小没有管理，二是越界操作没有检查。虽然C/C++也提供了一些解决办法，但总是不够完美。例如下面的代码：</p>
<pre><code>int ary[5];
memset(ary, 0, sizeof(ary));
unsigned int i = 0;
while(i&lt;sizeof(ary)/sizeof(ary[0])){
    ary[i] = i;
    i++;
}
</code></pre>
<p>C++11后，标准库引入了更现代化的数组std::array。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array<strong>不支持添加和删除元素以及改变容器大小的操作</strong>。与内置数组一样，标准库array的大小也是类型的一部分。<strong>当定义一个array时，除了指定元素类型，还要指定容器大小</strong>（array&lt;T,N&gt; 模板定义了一种相当于标准数组的容器类型。它是一个<strong>有 N 个 T 类型元素的固定序列</strong>）。为了使用array类型，我们必须同时指定元素类型和大小。array仅仅是为普通数组添加了一些成员或全局函数，这使得数组能够被当成标准容器来使用。array不能被动态地扩展或压缩。</p>
<p>和标准数组相比，array 容器的额外开销很小，但提供了两个优点：<strong>1）如果使用 at()，当用一个非法的索引访问数组元素时，能够被检测到，因为容器知道它有多少个元素；2）这也就意味着数组容器可以作为参数传给函数，而不再需要单独去指定数组元素的个数。</strong></p>
<p>使用 array 容器类型时，需要在源文件中包含头文件 array。下面展示了如何创建具有 10 个 double 型元素的 array&lt;&gt;，该实例定义了一个 array 容器，却没有为元素指定初始值，那么元素就不会被初始化：</p>
<pre><code>std::array&lt;double,10&gt; arr;
</code></pre>
<p>但是可以如下所示，将它们初始化为 0 或者和默认元素类型等效的值。使用下面语句初始化后，容器中所有的元素都会变为 0.0。</p>
<pre><code>std::array&lt;double,10&gt; arr{};
</code></pre>
<p>当然，当创建 array 容器的实例时，要像创建常规数组那样，对元素进行初始化：</p>
<pre><code>std::array&lt;double, 10&gt; arr {0.5, 1.0, 1.5, 2.0};
</code></pre>
<p>初始化器列表中的 4 个值用于初始化前 4 个元素，其余的元素都将为 0。</p>
<p>回到我们最初的原生内置数组代码，我们可以利用array编写如下代码：</p>
<pre><code>std::array&lt;int, 5&gt; c11ary;
c11ary.fill(0);
unsigned int i = 0;
while(i&lt;c11ary.size()){
    c11ary.at(i) = i;
    i++;
}
</code></pre>
<p>这段代码中:</p>
<ul>
<li>使用fill方法实现了数据填充。</li>
<li>使用size方法取得数组的大小。</li>
<li>虽然at(i)方法实现带有越界检查的读写。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：返回类型后置]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/">
        </link>
        <updated>2020-06-05T07:46:07.000Z</updated>
        <summary type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
]]></summary>
        <content type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
<!-- more -->
<p>除了构造函数和析构函数以外，函数声明都需要明确函数的返回类型，在传统的C或者C++中，函数声明大致是这个样子：</p>
<pre><code>int getSum(int a, int b);
</code></pre>
<p>第一个int就是函数的返回类型，它表明函数的返回值类型为整数。在新的C++11以后，我们也可以这样声明：</p>
<pre><code>auto getSum(int a, int b)-&gt;int;
</code></pre>
<p>在原来放返回值类型的位置写auto，在函数声明结束以后接一个'-&gt;'再跟着写函数的返回值类型。两种方式的效果是一样的。</p>
<hr>
<p><strong>更优雅的用法：</strong></p>
<p>在介绍返回类型后置之前，我们先来再谈一组令人头大的概念：<strong>数组指针</strong>和<strong>指针数组</strong>......（回想起了被指针常量和常量指针支配的恐惧 -_-）</p>
<ul>
<li><strong>数组指针</strong>：可以理解为**“数组的指针”<strong>，即首先这个变量是一个</strong>指针**，其次，“数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
<ul>
<li>e.g：*<em>char (<em>pa)[4];</em></em></li>
<li>pa是一个指针指向一个char [4]的数组，每个数组元素是一个char类型的变量，所以我们不妨可以写成：char[4] (*pa);这样就可以直观的看出pa的指向的类型。（不过在编辑器中不要这么写，因为编译器根本不认识，这样写只是帮助我们理解。）</li>
</ul>
</li>
<li><strong>指针数组</strong>：可以理解为**“指针的数组”<strong>，首先这个变量是一个</strong>数组**，其次，“指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。
<ul>
<li>e.g：*<em>char <em>arr[4] = {&quot;hello&quot;, &quot;world&quot;, &quot;shannxi&quot;, &quot;xian&quot;};</em></em></li>
<li>arr就是定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。</li>
</ul>
</li>
</ul>
<p>P.s：<strong>指针数组和数组指针的形成的根本原因就是运算符的优先级问题</strong>，所以定义变量是一定要注意这个问题，否则定义变量会有根本性差别！</p>
<p>在明白了<strong>数组指针</strong>和<strong>指针数组</strong>的概念后，我们来聊聊返回类型后置的一种优雅的用法：</p>
<p>一般情况下，当函数要返回多个数据时，会选择将数据封装在类（或结构体）中返回，或者直接返回一个指针。这两种方式要么麻烦，要么没有办法取得数据的数量。其实我们真正的需求就是返回一个数组（可以计算维度的）指针。这种方法是存在的：</p>
<blockquote>
<p>e.g:int (*getResultArray(int mode))[10];</p>
</blockquote>
<p>结合数组指针和指针数组的定义，上面的是数组指针还是指针数组呢？应该是<strong>数组指针</strong>。通过上面的形式，声明了一个返回包含10个整数的数组的指针。对于这样一个指针，我们可以像数组一样使用：</p>
<pre><code>auto arr = getResultArray(1);
cout &lt;&lt; sizeof(*arr)/sizeof(**arr) &lt;&lt; endl; //可以正确计算维度。
</code></pre>
<p>我们其实也可以这样做：</p>
<pre><code>typedef int arr10[10];
arr10* getResultArray(int mode)
</code></pre>
<p>C++11增加了返回类型后置以后，我们有了新的选择：</p>
<pre><code>auto getResultArray(int mode)-&gt;int(*)[10]；
</code></pre>
<p>比第一种形式容易理解很多。也不需要自定义类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的cbegin和cend函数 ]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/">
        </link>
        <updated>2020-06-05T03:41:53.000Z</updated>
        <summary type="html"><![CDATA[<p>小众的常量迭代器</p>
]]></summary>
        <content type="html"><![CDATA[<p>小众的常量迭代器</p>
<!-- more -->
<p>这个新特征其实是偶尔在别人的总结中看到的，但觉得确实很有趣，就做个记录：</p>
<h2 id="1-需求">1. 需求</h2>
<p>我们一般在使用STL容器时，下面代码是非常常见的：</p>
<pre><code>int sum = 0;
vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator it = v.begin();
while(it != v.end()){
       sum += *it;
       it++;
 }
</code></pre>
<p>但是，如果我们一旦定义容器为常量，就必须注意迭代器也需要声明为常量：</p>
<pre><code>int sum = 0;

//编译错误：原因是定义的vector是const类型，所以迭代器必须也是const类型
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
 }

//正确写法：
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::const_iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
}
</code></pre>
<p>这显然很麻烦，一个简单的方法是直接使用auto来自动推断迭代器类型（想必大家都更倾向于这样，毕竟...有了auto还要啥自行车）：</p>
<pre><code>auto ait = cv.begin();
while(ait != cv.end()){ 
       sum += *ait;
       ait++;
 }
</code></pre>
<h2 id="2-优势">2. 优势</h2>
<p>但我们也不难想到存在这样一种情形：<strong>数据本身不是const类型，但是从设计的角度来讲有些处理不应该修改该数据</strong>。这时也应该要求const类型的迭代器，以避免数据被意外修改。所以，C++11为此提供了cbegin和cend方法。</p>
<pre><code>vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
auto ait = v.cbegin();
while(ait != v.cend()){
           sum += *ait;
           *ait = sum;  //编译错误
           ait++;
}
</code></pre>
<p>cbegin()/cend()决定了返回的迭代器类型为const。这时即使vector的类型不是const，也可以防止对该数据的误操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：常量表达式]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-chang-liang-biao-da-shi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-chang-liang-biao-da-shi/">
        </link>
        <updated>2020-06-05T02:05:16.000Z</updated>
        <summary type="html"><![CDATA[<p>常量+指针......可真是太难了</p>
]]></summary>
        <content type="html"><![CDATA[<p>常量+指针......可真是太难了</p>
<!-- more -->
<p>总体而言，常量本身并不难理解：使用<strong>const</strong>关键词限定的量被认为是常量；常量一旦初始化便不允许修改。然而，C++中最让人头疼的概念莫过于指针了，因此常量一旦结合指针......极致的快乐就来了。单单脑补一下这两个名词：指针常量、常量指针......就够头大了。因此，在正式开始之前，我还是得复习一下C++中指针的概念。</p>
<h2 id="1-指针">1. 指针</h2>
<p>首先，所谓指针，其本质仍然是一个变量，但其值为另一个变量的地址，即，内存位置的直接地址。<br>
提到指针，其实理解的关键在于理解两个运算符——<strong>“*”和“&amp;”</strong>：</p>
<ul>
<li>** “*”**：被称为间接值或解除引用运算符，将其用于指针，<strong>可得到该地址处所存储的值</strong>。（由于指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的值就是一个变量的地址，因此，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">*p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord">∗</span><span class="mord mathdefault">p</span></span></span></span>就是该指针所指向变量的值）。</li>
<li><strong>“&amp;”</strong>：地址运算符，用于访问变量的地址。</li>
</ul>
<p>所以，根据指针的定义以及“*”和“&amp;”的用法，我们可以更好地理解C++中指针的声明和初始化：</p>
<pre><code>//初始化方式1：先声明，后初始化——更好理解
int a = 25;
int *ptr_a;
ptr_a = &amp;a;

//初始化方式2：声明同时初始化——更常用，也更安全
int b = 20;
int *ptr_b = &amp;b;        /P.s:是将ptr_b初始化，即：将ptr_b（而不是*ptr_b）的值设置为&amp;b。

//初始化方式3：数组初始化
int c[10];
int *ptr_c1 = c;  
int *ptr_c2 = &amp;c[0];
</code></pre>
<p>为了加深理解，再给几个例子，你品，你细品：</p>
<pre><code>//错误示例：p仅声明了而没有初始化，所以p所指向的内存位置是随机的。
int  *p;
*p = 7;

//正确示例：
int k = 1, m = 3;

int *p;
p = &amp;k; //给p赋值
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

*p = 7; //给p所指向的内存赋值，即k= 7
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

p = &amp;m;
cout &lt;&lt; &amp;k &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;m &lt;&lt; endl;
cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; endl;

/*
最终输出：
0x7ffee6e7974c 0x7ffee6e7974c 0x7ffee6e79748
1 1 3
0x7ffee6e7974c 0x7ffee6e7974c 0x7ffee6e79748
7 7 3
0x7ffee6e7974c 0x7ffee6e79748 0x7ffee6e79748
7 3 3
*/
</code></pre>
<h2 id="2-指针常量-常量指针">2. “指针常量” &amp; “常量指针”</h2>
<p>如果，到这里还顶得住，那我们来谈谈一开始我们说的“指针常量”和“常量指针”：<br>
这两个概念其实从本科一直到研究生我都一直在“懂了”-“晕了”之间反复横跳～直到在<a href="https://www.zhihu.com/question/19829354">知乎</a>看到一个非常有趣的解释，突然之间———我觉得我又可以了：<br>
其实，常量和指针的结合方式共有6种：<br>
①const int p;<br>
②const int* p;<br>
③int const* p<br>
④int * const p;<br>
⑤const int * const p;<br>
⑥int const * const p;</p>
<p>①其实没什么好说的，平平无奇的一个常量整数。然而，后面几个，emmm...老千层饼了，直接劝退。<br>
先别怕，这里其实有一套实用的技巧：</p>
<ul>
<li>从右往左读；</li>
<li>遇到p就替换成“p is a ”；</li>
<li>遇到*就替换成“point to”。</li>
</ul>
<p>例如：<br>
②读作：“p is a point to int const.”--这说明p是一个指向整型常量的指针。<br>
③读作：“p is a point to const int.” --意思跟②相同。<br>
④读作：“p is a const point to int.”--p是一个常量指针，指向整型。<br>
⑤读作：“p is a const point to int const.”<br>
⑥读作：“p is a const point to const int.”--⑤和⑥的意思相同，p都是常量指针，指向整型常量。<br>
这里再说明一下：如果p是一个指针，指向常量，说明指向的常量的值是不能更改的；如果p是一个常量指针，指向整型，说明p的值（存的地址）是不能更改的（老千层饼*2）。可以再给一个例子：</p>
<pre><code>const double pi = 3.14;
const double  *cptr = &amp;pi;    //指向常量的指针
*cptr = 4;            //cptr存的是常量pi的地址，所以*cptr常量pi的地址所指向的值。因此，该语句其实是企图更改常量的值——编译错误


double var1 = 45, var2=50;
double *const  pvar = &amp;var1;  //常量指针，指向double变量。
*pvar = 40;       //与上一个例子相同，这里是企图改变var1的值，而不是改变常量指针存储的值——正确

pvar = &amp;var2;   //该语句实质是想改变常量指针里面存储的地址——编译错误
</code></pre>
<p>到这里，应该说清楚了吧......</p>
<h2 id="3-常量表达式">3. 常量表达式</h2>
<h3 id="31-什么是常量表达式">3.1 什么是常量表达式</h3>
<p>常量表达式是指值不会改变并且在<strong>编译过程</strong>就能够得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。如下：</p>
<pre><code>const int max_num = 20;           // max_num是常量表达式
const int limit = max_num + 1;    // limit 是常量表达式
int staff_size = 2;               // staff_size 不是常量表达式，因为staff_size没有用const修饰
const int zs = get_size();        // sz 不是常量表达式，虽然sz是个常量，但它的值在运行时才能确定
</code></pre>
<p>可见：<strong>一个对象（或表达式）是不是常量表达式由它的数据类型（是否const）和初始值共同决定。</strong></p>
<h3 id="32-constexprconst-expression">3.2 constexpr(const expression)：</h3>
<p>const可以用来修饰常量，可是只有当其初始值是个常量表达式时，const修饰的对象才是个常量表达式。一般来说，在日益复杂的系统中确定变量的初始值到底是不是常量表达式并不是一件容易的事。为了解决这个问题C++11允许将变量声明为<strong>constexpr</strong>类型以便由编译器验证变量的值是否是一个常量表达式。一般而言，<strong>如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。constexpr 变量在定义时必须初始化</strong>。</p>
<pre><code>constexpr int mf = 20;		// mf是常量表达式
constexpr int limit = mf + 1;	// limit 是常量表达式
constexpr int sz = get_sz();	// 只有当 get_sz() 是一个 constexpr 函数时才是一条正确的声明语句
</code></pre>
<h3 id="33-指针和constexpr">3.3 指针和constexpr</h3>
<p>从上面的介绍不难看出，变量声明为constexpr类型，就意味着<strong>一方面变量本身是常量，也意味着它必须用常量表达式来初始化</strong>。所以，当 constexpr 修饰指针时，constexpr 仅对指针有效，与指针所指的对象无关：</p>
<pre><code>const int *p = nullptr;		// p 是指向常量的指针
constexpr int *q = nullptr;	// q 是常指针，constexpr 仅对指针有效
</code></pre>
<p>当然，const 和 constptr 可以一起来修饰一个指针，用于表明指向常量的常指针:</p>
<pre><code>constexpr const int *p = &amp;i;	
// 指向常量的常指针，注意 &amp;i 必须是常量表达式，i可以是全局变量或静态变量等等。。这些变量的地址在编译时就确定了
</code></pre>
<h3 id="34-constexpr函数">3.4 constexpr函数</h3>
<p>除了能用常量表达式初始化constexpr变量以外，还可以使用constexpr函数。它是指<strong>能用于常量表达式的函数，也就是说它的计算结果可以在编译时确定</strong>。定义的方法就是在<strong>返回值类型前加constexpr关键字</strong>。但是为了保证计算结果可以在编译是确定，必须满足以下条件：</p>
<ul>
<li>返回值和形参必须都是字面值类型。</li>
<li>函数中只能有一条return语句。</li>
</ul>
<pre><code>constexpr long long factorial(int n){

   return n &lt;= 1? 1 : (n * factorial(n - 1));

}

constexpr long long f18 = factorial(20);
</code></pre>
<h3 id="35-总结">3.5 总结</h3>
<p>constexpr可以：</p>
<ul>
<li>加强初始值的检查</li>
<li>计算的时机从运行时提前到编译时，比宏定义效率更高。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特性：列表初始化]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-xing-lie-biao-chu-shi-hua/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-xing-lie-biao-chu-shi-hua/">
        </link>
        <updated>2020-06-04T09:13:03.000Z</updated>
        <summary type="html"><![CDATA[<p>优雅的初始化方式</p>
]]></summary>
        <content type="html"><![CDATA[<p>优雅的初始化方式</p>
<!-- more -->
<p>回想一下，之前C或者C++在初始化数组时，可以使用下面的花括号加初始值的形式：</p>
<pre><code>int int_array[] = {1, 2, 3, 4, 5};
</code></pre>
<p>这对于常使用C++的程序员而言，是一种司空见惯的写法。然而，这种方法的运用范围很窄，许多场景都用不了。最典型的例子莫过于vector：可以像数组一样使用，可以自己管理数据长度，还提供各种操作数组的方法。声明的方法也很简单：</p>
<pre><code>vector&lt;int&gt; int_vector;
</code></pre>
<p>但是有一个问题，当需要指定元素初始化vector时就不那么方便了，传统的初始化方法有以下几类：</p>
<pre><code>//方法1:逐一压入
int_vector.push_back(5);
int_vector.push_back(4);
int_vector.push_back(3);
int_vector.push_back(2);
int_vector.push_back(1);
//方法2:统一赋值——int_vector共有10个元素，每个元素都是8
vector&lt;int&gt; int_vector(10,8)；
</code></pre>
<h2 id="列表初始化">列表初始化</h2>
<p>C++11中扩展了使用<strong>花括号</strong>初始化变量的应用范围，称这种初始化方式为列表初始化。例如，可以像下面这样初始化vector、list、map:</p>
<pre><code>vector&lt;int&gt; int_vector = {5, 4, 3, 2, 1};
list&lt;int&gt; int_list = {5, 4, 3, 2, 1};
map&lt;int, const char*&gt; id2Name = {{1,&quot;Zhang&quot;},{2, &quot;Wang&quot;},{3, &quot;Li&quot;}};
</code></pre>
<p>更简单的还有以下写法：</p>
<pre><code>vector&lt;int&gt; int_vector{5, 4, 3, 2, 1};

list&lt;int&gt; int_list {5, 4, 3, 2, 1};

map&lt;int, const char*&gt; id2Name{{1,&quot;Zhang&quot;},{2, &quot;Wang&quot;},{3, &quot;Li&quot;}};
</code></pre>
<p>舒服了～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：基于范围的for循环]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-ji-yu-fan-wei-de-for-xun-huan/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-ji-yu-fan-wei-de-for-xun-huan/">
        </link>
        <updated>2020-06-04T08:13:10.000Z</updated>
        <summary type="html"><![CDATA[<p>像python一样，优雅地简化对数组、容器的遍历代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>像python一样，优雅地简化对数组、容器的遍历代码。</p>
<!-- more -->
<p>其实很多时候还是很羡慕python中for循环的写法的，直到发现...原来C++11原来也有这么优雅的循环写法，真香！<br>
为了在遍历容器时支持“foreach”用法，C++11扩展了for语句的语法。用这个新的写法，<strong>可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型</strong>。 如果你只是想对集合或数组的每个元素做一些操作，而不关心下标、迭代器位置或者元素个数，那么这种foreach的for循环将会非常有用。</p>
<h2 id="1-基于范围的for循环">1. 基于范围的for循环</h2>
<p>循环最常见的的场景就是对数据集合的每一个元素进行某种操作。C++11之前，大致是这样的程序：</p>
<pre><code>int a[] = {1, 2, 3, 4};

int sum = 0;

for(int i = 0 ; i &lt; sizeof(a)/sizeof(a[0]); ++i)｛

        sum += a[i];

｝

vector&lt;int&gt; v{1, 2, 3,4};

int sum = 0;

for(auto it = v.begin(); it != v.end(); it++){

    sum += *it;

}
</code></pre>
<p>而在C++11 引入基于范围的for循环后，循环可以优雅地写成下面这样：</p>
<pre><code>int array[]{1, 2, 3, 4};

int sum = 0;

 for(int a : array){

     sum += a;

}

vector&lt;int&gt; vect{1, 2, 3, 4};

int sum = 0;

for(int v: vect){

    sum += v;

}
</code></pre>
<p>for(int v : vect)可以理解为“对于vect中的每一个v”。</p>
<h2 id="2-应用条件">2. 应用条件</h2>
<p>正如之前所说，数据v被范围for遍历的条件是，该<strong>数据支持v.begin()/v.end()或者是begin(v)/end(v)并返回一个迭代器</strong>。STL中的容器都满足上述条件。对于内置类型的数组来讲C++编译器提供了等同于上述接口的机制，因此也可以在范围for中使用。</p>
<h2 id="3-完整示例">3. 完整示例</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main() {
    std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5};
 
    for (const int&amp; i : v) // 以 const 引用访问
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto i : v) // 以值访问，i 的类型是 int
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (auto&amp; i : v) // 以引用访问，i 的类型是 int&amp;
        std::cout &lt;&lt; i &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (int n : {0, 1, 2, 3, 4, 5}) // 初始化器可以是花括号初始化器列表
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    int a[] = {0, 1, 2, 3, 4, 5};
    for (int n : a) // 初始化器可以是数组
        std::cout &lt;&lt; n &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    for (int n : a)  
        std::cout &lt;&lt; 1 &lt;&lt; ' '; // 不必使用循环变量
    std::cout &lt;&lt; '\n';
 
}

//输出为
// 0 1 2 3 4 5
// 0 1 2 3 4 5
// 0 1 2 3 4 
// 0 1 2 3 4 5
// 0 1 2 3 4 5
// 1 1 1 1 1 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：Lambda函数与表达式]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-han-shu-yu-biao-da-shi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-han-shu-yu-biao-da-shi/">
        </link>
        <updated>2020-06-04T06:47:21.000Z</updated>
        <content type="html"><![CDATA[<p>其实，最开始接触到lambda函数是在关于python匿名函数的教程中。后来在一些资料上也看到了关于C++中匿名函数的用法的相关讲解。那么，借着这次整理C++11新特征的机会，就对C++中的lambda函数进行一下归纳：</p>
<h2 id="1-lambda-函数与表达式">1. Lambda 函数与表达式</h2>
<p>C++11 提供了对匿名函数的支持（即，没有函数名的函数）,称为** Lambda 函数(也叫 Lambda 表达式)**。其作用主要在于，如果代码里面存在大量的小函数，而这些函数一般只被一两处调用，那么不妨将它们重构成Lambda表达式，也就是匿名函数。作用就是当你想用一个函数，但是又不想费神去命名一个函数。</p>
<p>Lambda 表达式本质上与函数声明非常类似，其通用表达形式——$[捕获区] (参数区)-&gt;返回类型 {代码区}：</p>
<ul>
<li><strong>[捕获区]</strong>，指定在可见域范围内lambda表达式代码内可见的参数，即（除了形参之外）它可以使用的变量列表。<strong>在Lambda表达式内可以访问当前作用域的变量</strong>，这是Lambda表达式的闭包（Closure）行为：
<ul>
<li>[]，沒有定义任何变量，即不捕获外部的任何变量。使用未定义变量会引发错误。</li>
<li>[x, &amp;y]，x以传值方式传入（默认），y以引用方式传入。</li>
<li>[&amp;]，任何被使用到的外部变量都隐式地以引用方式加以引用。</li>
<li>[=]，任何被使用到的外部变量都隐式地以传值方式加以引用。</li>
<li>[&amp;, x]，x显式地以传值方式加以引用。其余变量以引用方式加以引用。</li>
<li>[=, &amp;z]，z显式地以引用方式加以引用。其余变量以传值方式加以引用。</li>
<li>[this]，以值的方式捕获 this 指针。</li>
</ul>
</li>
<li><strong>(参数区)</strong>，指定lambda表达式内部变量定义</li>
<li><strong>-&gt;返回类型</strong>，是返回类型，如果 lambda 代码块中包含了 return 语句，则该 lambda 表达式的返回类型由 return 语句的返回类型确定。如果没有 return 语句，则类似 void f(…) 函数。</li>
<li><strong>{代码区}</strong>，是Lambda表达式主题结构。</li>
</ul>
<p>例如：</p>
<pre><code>//通用表达形式：[捕获区](参数区)-&gt;返回类型 {代码区};
int n = [] (int x, int y) { return x + y; }(5, 4);      //n=9
</code></pre>
<p>P.s：Lambda函数通过“函数体”后面的‘()’传入参数，如上例中的（5,4）。</p>
<h2 id="2-使用场景">2. 使用场景</h2>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。就目前来看，Lambda函数最常用的使用场景在于：sort、for_each等自定义比较函数。</p>
<p>下面给出了一个非常具体且完整的Lambda表达式的使用样例，可帮助我们加深理解：</p>
<pre><code>class CTest 
{ 
 public:  
   CTest() : m_nData(20) { NULL; }  
   void TestLambda()  
   {   
     vector&lt;int&gt; vctTemp;   
     vctTemp.push_back(1);   
     vctTemp.push_back(2);    

   // 无函数对象参数，输出：1 2   
   {    
     for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout &lt;&lt; v &lt;&lt; endl; });   
   }   

   // 以值方式传递作用域内所有可见的局部变量（包括this），输出：11 12   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [=](int v){ cout &lt;&lt; v+a &lt;&lt; endl; });   
   }    

   // 以引用方式传递作用域内所有可见的局部变量（包括this），输出：11 13 12   
   {    
     int a = 10;   
     for_each(vctTemp.begin(), vctTemp.end(), [&amp;](int v)mutable{ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;   
   }    

   // 以值方式传递局部变量a，输出：11 13 10   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [a](int v)mutable{ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;   
   }    

   // 以引用方式传递局部变量a，输出：11 13 12   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [&amp;a](int v){ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;  
   }    

   // 传递this，输出：21 22 
   {  
     for_each(vctTemp.begin(), vctTemp.end(), [this](int v){ cout &lt;&lt; v+m_nData &lt;&lt; endl; });   
   }    

   // 除b按引用传递外，其他均按值传递，输出：11 12 17   
   {    
     int a = 10;    
     int b = 15;    
     for_each(vctTemp.begin(), vctTemp.end(), [=, &amp;b](int v){ cout &lt;&lt; v+a &lt;&lt; endl; b++; });    
     cout &lt;&lt; b &lt;&lt; endl;   
   }     
   // 操作符重载函数参数按引用传递，输出：2 3   
   {    
     for_each(vctTemp.begin(), vctTemp.end(), [](int &amp;v){ v++; });    
     for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout &lt;&lt; v &lt;&lt; endl; });   
   }    
   // 空的Lambda表达式   
   {    
     [](){}();    []{}();   
   }  
 }  
 private:  int m_nData; 
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：nullptr空指针]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-nullptr-kong-zhi-zhen/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-nullptr-kong-zhi-zhen/">
        </link>
        <updated>2020-06-04T03:05:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-空指针">1. 空指针</h2>
<p>在谈nullptr之前，我们先聊聊C++中的空指针：<br>
在指针变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。<strong>NULL 指针是一个定义在标准库中的值为零的常量</strong>。例如：</p>
<pre><code>#include &lt;iostream&gt;
//程序将输出：ptr 的值是 0
using namespace std;

int main ()
{
   int  *ptr = NULL;
   // int *ptr = 0; 

   cout &lt;&lt; &quot;ptr 的值是 &quot; &lt;&lt; ptr ;
 
   return 0;
}
</code></pre>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。如需检查一个空指针，可以使用 if 语句，如下所示：</p>
<pre><code>if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
//个人常用的方式：
if(ptr!=NULL)       /* 如果 ptr 非空，则完成 */
if(ptr==NULL)   /* 如果 ptr 为空，则完成 */
</code></pre>
<p>所以，综上所述，声明一个空指针可有两种方式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mi>p</mi><mo>=</mo><mi>N</mi><mi>U</mi><mi>L</mi><mi>L</mi><mi mathvariant="normal">或</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">int* p = NULL 或 int* p = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">或</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。<br>
此处对<strong>NULL</strong>和<strong>常数0</strong>进行一些整理：</p>
<ul>
<li>NULL到底是什么？NULL的实质是一个在标准库头文件&lt;stddef.h&gt;中定义的宏。</li>
<li>它的值是多少？C/C++标准规定：它的值是一个空指针常量（null pointer constant），由实现定义。</li>
<li>什么样的值才能称之为空指针常量？C语言中常数0和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo>∗</mo><mo>)</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(void*)0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">∗</span><span class="mclose">)</span><span class="mord">0</span></span></span></span>都是空指针常量；C++中（暂且忽略C++11）常数0是，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo>∗</mo><mo>)</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(void*)0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">∗</span><span class="mclose">)</span><span class="mord">0</span></span></span></span>不是。</li>
</ul>
<p>其实我们查看对NULL的定义即可明白：</p>
<pre><code>if defined(__cplusplus)
define NULL 0    // C++中使用0作为NULL的值
else
define NULL ((void *)0)    // C中使用((void *)0)作为NULL的值
endif
</code></pre>
<h2 id="2-nullptr">2. nullptr</h2>
<p>通过上述介绍，我们不难看出，在编程的世界里0有双重的角色，可以表示整数零，也可以表示一个空指针。在C语言中，通过预编译宏NULL，可以区分0表示的是零还是(void*)0。但是，在C++的世界中，这样是不可以的。加之C++中允许函数重载，这便对空指针的声明产生了影响，例如：</p>
<pre><code>void foo(char *);
void foo(int);
</code></pre>
<p>如果把NULL定义为0，那么foo(NULL)将调用哪个函数呢？</p>
<pre><code>#include &lt;stddef.h&gt;
void foo(int) {}     // #1
void foo(char*) {}   // #2
int main() {
    foo(NULL); // 调用#1还是#2？
}
</code></pre>
<p>从字面上来讲，NULL是个空指针常量，我们可能会觉得：既然是个指针，那么应该调用#2。但事实上调用的却是#1，因为C++中NULL扩展为常数0，它是int型。<br>
为了解决常数0既是整数常量，也是空指针常量这样的二义性问题，C++11引入了另一个关键字nullptr，作为一个空指针。例如：</p>
<pre><code>char *pc = nullptr;     // OK
int  *pi = nullptr;     // OK
bool   b = nullptr;     // OK. b is false.
int    i = nullptr;     // error

foo(nullptr);           // calls foo(char *), not foo(int);
</code></pre>
]]></content>
    </entry>
</feed>