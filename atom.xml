<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mocuishle0.github.io/</id>
    <title>MoCuishle</title>
    <updated>2020-06-07T13:35:06.217Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mocuishle0.github.io/"/>
    <link rel="self" href="https://mocuishle0.github.io/atom.xml"/>
    <subtitle>我拥有的都是侥幸，
我失去的都是人生。</subtitle>
    <logo>https://mocuishle0.github.io/images/avatar.png</logo>
    <icon>https://mocuishle0.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MoCuishle</rights>
    <entry>
        <title type="html"><![CDATA[To: 圆宝]]></title>
        <id>https://mocuishle0.github.io/post/to-yuan-bao/</id>
        <link href="https://mocuishle0.github.io/post/to-yuan-bao/">
        </link>
        <updated>2020-06-07T12:47:42.000Z</updated>
        <content type="html"><![CDATA[<p>你好呀～周圆圆🤗<br>
生日快乐啦～哈哈哈，没想到吧，疫情原因就不给你写纸质情书了～写个电子版情书💌好啦（我承认这个创意有抄袭你的成分～）咳咳～我圆姐也第二轮啦（虽然我一直搞不清楚你到底是属牛呢还是属鼠～哈哈哈哈 不影响）哈哈哈，但是我圆姐永远18（毕竟连鱼尾纹都没有 哈哈哈哈 想想我～真的是。。。嘤嘤嘤）</p>
<p>那么～作为一个生日小情书～我是不是应该放点照片回顾一下咱们在一起的点点滴滴呢（是不是好紧张～担心看到自己辣眼睛的照片呀～）哈哈哈，别紧张～我这么温柔、善良、纯洁～当然不会放你的黑照啦（我真好 哈哈哈哈）</p>
<p><img src="https://mocuishle0.github.io//post-images/1591535379999.JPG" alt="" loading="lazy"><br>
来来来，先放一张伪结婚照（真的很像 哈哈哈哈哈）～哈哈哈哈 这还是咱们本科毕业时候照的呢～等咱们研究生毕业了一定得再照一个～哈哈哈哈太有纪念意义了😙越看越觉得圆姐好好看～哈哈哈（虽然我也很好看🤣）</p>
<p><img src="https://mocuishle0.github.io//post-images/1591535537903.JPG" alt="" loading="lazy"><br>
哈哈哈哈～这个应该是咱俩的第一个“合影”吧～哈哈哈 你还记得这是啥时候的不～属鱼的小圆圆～哈哈哈 现在想想那时候可真好～</p>
<p><img src="https://mocuishle0.github.io//post-images/1591535702572.JPG" alt="" loading="lazy"><br>
哈哈哈哈 乱入一张奇奇怪怪的“合影”，哈哈哈哈哈 英勇笑哥，在线揍狼～</p>
<p><img src="https://mocuishle0.github.io//post-images/1591535801799.JPG" alt="" loading="lazy"><br>
好吧～本来不想放这个的～但是。。。哈哈哈哈 真的很有趣了～我们今晚还去那溜达了 下次我们好好去那拍一张～</p>
<p><img src="https://mocuishle0.github.io//post-images/1591535950354.JPG" alt="" loading="lazy"><br>
哈哈哈哈～这个当时拍的真的好非主流的呀～（但不影响它甜）哈哈哈哈～今天可真的是考古</p>
<p><img src="https://mocuishle0.github.io//post-images/1591536278283.jpg" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1591536330844.JPG" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1591536352315.jpg" alt="" loading="lazy"><br>
那合影当然要有咱们一起1旅行的记忆呀1～真是太美了～哈哈哈 那段时间真的超开心的呀</p>
<p><img src="https://mocuishle0.github.io//post-images/1591536167020.PNG" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1591536127755.JPG" alt="" loading="lazy"><br>
我可真的是太喜欢上次咱们拍的这些照片了 哈哈哈哈 太可爱了咱们两</p>
<p>哈哈哈～我其实整理了好多照片呢～真的是越看越想～好好的抱抱你 嘻嘻～谢谢圆圆一直陪着我～mua～<br>
呀～就不说骚情话了～哈哈哈 反正我骚话说起来就没完没了～其实呢～就是想说：</p>
<blockquote>
<p>我好中意你呀～我一直一直好中意你呀～</p>
</blockquote>
<p>哈哈哈哈（还是很骚～）呀 你懂的啦～么么哒</p>
<p>其实本来还想写一些的。。。然而。。。我妹妹疯狂发微信让我给他讲几道题。。。我太难了。。。嘤嘤嘤～</p>
<p>不过～还有个小彩蛋要送给你哦～</p>
<p>哈哈哈，虽然生日礼物你已经收到了～但是～我还是准备了个小惊喜哦～登登登登：<br>
<img src="https://mocuishle0.github.io//post-images/1591534430257.jpg" alt="" loading="lazy"><br>
哈哈哈哈，是不是还挺直男的～<br>
其实，我本来准备了300多张照片做素材呢，我本来以为做粗来会是里面每张照片各不相同呢～结果由于照片色域的问题好多都是重复的～稍稍不尽人意 哈哈哈哈 但应该不影响整体效果啦😂希望圆圆喜欢这个直男风的小惊喜～哈哈哈哈哈 mua～</p>
<p>❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️❤️～To my lover～</p>
<p>（写完才发现。。这个博客的排版。。。哈哈哈 呀～但我的爱还是满满的哦～）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：Lambda表达式（续）]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-biao-da-shi-xu/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-biao-da-shi-xu/">
        </link>
        <updated>2020-06-07T08:17:54.000Z</updated>
        <summary type="html"><![CDATA[<p>上一次总结Lambda表达式后，又陆陆续续看到许多关于Lambda表达式的资料，又有了许多新的感触。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一次总结Lambda表达式后，又陆陆续续看到许多关于Lambda表达式的资料，又有了许多新的感触。</p>
<!-- more -->
<h2 id="1-更常见的应用场景">1. 更常见的应用场景</h2>
<p>在上一篇介绍Lambda表达式的文章中，已经提及Lambda结合sort函数的应用场景，但并未展开。其实，相较于上一篇文章中那个具体的例子，sort函数（find_if函数同理）结合Lambda表达式其实更易于理解：在引入Lambda表达式之前，我们要对容器中的元素进行自定义的排序需要自己定义一个比表函数（也被称为 “谓词”），如下：</p>
<pre><code>bool compare(const string&amp; s1, const string&amp; s2){
    return s1.size() &lt; s2.size();
}

vector&lt;string&gt; v{&quot;This&quot;,&quot;is&quot;, &quot;a&quot;, &quot;predicate&quot;, &quot;.&quot;};
sort(v.begin(), v.end(), compare);
for(auto s:v){
    cout &lt;&lt; s &lt;&lt; endl;
}
/*
输出：
.
a
is
This
predicate
*/
</code></pre>
<p>在这个例子中，我们定义了一个函数传递给sort算法。这个函数可以重复使用还好，如果只是用使用一次的话就显得比较麻烦。这种情况下可以使用C++11提供的新特性：lamada表达式。代码如下：</p>
<pre><code>vector&lt;string&gt; v{&quot;This&quot;,&quot;is&quot;, &quot;a&quot;, &quot;predicate&quot;, &quot;.&quot;};
sort(v.begin(), v.end(),[](const string&amp; s1, const string&amp; s2){
        return s1.size() &gt; s2.size();
      });
for(auto s:v){
    cout &lt;&lt; s &lt;&lt; endl;
}
/*
输出：
predicate
This
is
.
a
*/
</code></pre>
<h2 id="2-可变lambda">2. 可变Lambda</h2>
<p>在一些资料里还看到了一个有趣的例子：<br>
假设有如下vector，保存的内容是学生的考试成绩，可以用以下代码来寻找第一个及格成绩：</p>
<pre><code>vector&lt;int&gt; score{45, 70, 56, 86, 28, 60, 90};
find_if(score.begin(), score.end(), 
        [](int v){return (v &gt;=60);});
</code></pre>
<p>如果需要找到第n个及格成绩，很自然地会考虑使用下面的代码：</p>
<pre><code>vector&lt;int&gt; score{45, 70, 56, 86, 28, 60, 90};
int counter = 2;
find_if(score.begin(), score.end(), 
        [counter](int v){
           return (v &gt;=60)&amp;&amp;(--counter == 0);
        });
</code></pre>
<p>但是，这时会出现编译错误，告诉你counter是只读的。其原因是因为在lambda表达式中很少有需要修改捕获值的场景，因此<strong>默认捕获值具有const属性</strong>。如果出现本例这样，确实希望修改捕获值的情况，C++11使用<strong>mutable</strong>关键字来解决这个问题。来看完整代码：</p>
<pre><code>vector&lt;int&gt; score{45, 70, 56, 86, 28, 60, 90};
int counter = 2;
auto iter find_if(score.begin(), score.end(),
        [counter](int v)mutable{
           return (v &gt;=60)&amp;&amp;(--counter == 0);
        });
cout &lt;&lt; *iter &lt;&lt; endl;
</code></pre>
<p>需要注意的是，由于是<strong>值捕获</strong>，处于lambda表达式外面的counter值依然不会改变。如果希望连外面的counter一起修改，使用<strong>引用捕获</strong>即可。</p>
<h2 id="3-lambda表达式的递归调用">3. Lambda表达式的递归调用</h2>
<p>没想到吧～Lambda表达式也可以递归调用...老套娃了...<br>
直观地想，Lambda表达式由于不存在函数名，因此如何自己调用自己是一个比较棘手的问题。但是，还是有办法的。以阶乘为例：</p>
<pre><code>function&lt;int(int)&gt; factorial =[&amp;](int n){
           if(n &lt; 2) return 1;
           return n * factorial(n - 1);
        };
cout &lt;&lt; factorial(3) &lt;&lt; endl;
</code></pre>
<p>Lambda表达式的递归调用有几个要点：</p>
<ul>
<li>使用标准库中的<strong>function模版类型定义表达式类型</strong>，其中<strong>模版参数与lambda表达式的返回值，参数一致</strong>;</li>
<li>使用<strong>引用捕获</strong>来获得factorial的使用权;</li>
<li>调用factorial实现递归调用。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特性：string与数值转换函数]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-xing-string-yu-shu-zhi-zhuan-huan-han-shu/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-xing-string-yu-shu-zhi-zhuan-huan-han-shu/">
        </link>
        <updated>2020-06-07T07:50:41.000Z</updated>
        <summary type="html"><![CDATA[<p>我还以为这个不是新特征呢...</p>
]]></summary>
        <content type="html"><![CDATA[<p>我还以为这个不是新特征呢...</p>
<!-- more -->
<p>可能由于对于string的使用较多，所以该库中的一些方法也时常会被用到，因此对于string与数值转换函数也并未意识到这是C++11新特征中的一项。</p>
<p>P.s：数值和string的转换其实也可以通过<sstream>头文件下的stringstream进行转换。详细内容可参考：<a href="https://home.gamer.com.tw/creationDetail.php?sn=4114818">stringstream用法</a></p>
<h2 id="1-数值-string">1. 数值-&gt;string</h2>
<p>使用全局函数<strong>std::to_string</strong>：</p>
<pre><code>string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val)
</code></pre>
<p>以上函数实现了各类数值类型到string的转换。</p>
<h2 id="2-string-数值">2. string-&gt;数值</h2>
<p>针对基本的数值类型，C++11提供了相应的转换方法：</p>
<pre><code>stoi：string -&gt; int

stol:  string -&gt; long

stoll：string -&gt; long long

stoul：sting -&gt; unsigned long

stoull：string -&gt; unsigned long long.

stof：string -&gt; float

stod：string -&gt; double

stold：string -&gt; long double.
</code></pre>
<p>例如：</p>
<pre><code>string value = to_string(2.5);
int iv = stoi(value);
cout &lt;&lt; &quot;iv=&quot; &lt;&lt; iv &lt;&lt; endl;        //iv=2
double dv = stod(value);
cout &lt;&lt; &quot;dv=&quot; &lt;&lt; dv &lt;&lt; endl;        //dv=2.5
</code></pre>
<p>需要注意的是，string到数值转换函数的声明，会发现这些函数的第二个参数，例如stod的声明：</p>
<pre><code>double stod (const string&amp;  str, size_t* idx = 0);
</code></pre>
<p>参数idx用于保管数值之后下一个字符的位置。利用这个参数带回的结果，可以实现某些便利的处理，例如实现一个包含多个数值的string的连续转换：</p>
<pre><code>string values(&quot;1.0,2.4,3.5,4.6,5.7&quot;);
while(values.size()&gt;0){
    string::size_type sz;
    cout &lt;&lt; stod(values, &amp;sz) &lt;&lt; endl;
    if(sz &lt; values.size()){
        values = values.substr(sz + 1);
    }
    else{
        values.clear();
    }
}
/*
输出：
1
2.4
3.5
4.6
5.7
*/
</code></pre>
<p>除此之外，从当转换目标为整数时，可以通过第三个参数指定转换的基数，例如以下代码的输出结果就是256：</p>
<pre><code>string hex(&quot;100&quot;);
cout &lt;&lt; stoi(hex, nullptr, 16);     //256，即将一个16进制数值的字符串形式转换成10进制整型
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++：内存分配方式]]></title>
        <id>https://mocuishle0.github.io/post/cnei-cun-fen-pei-fang-shi/</id>
        <link href="https://mocuishle0.github.io/post/cnei-cun-fen-pei-fang-shi/">
        </link>
        <updated>2020-06-07T02:22:38.000Z</updated>
        <summary type="html"><![CDATA[<p>C++的内存分配方式是理解C++特征的基础。</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++的内存分配方式是理解C++特征的基础。</p>
<!-- more -->
<p>首先，我们主要根据《C++ Primer Plus》中的介绍进行一个总结：C++有三种管理数据内存的方式——<strong>自动存储、静态存储和动态存储</strong>（也称为自由存储空间 或 堆）。在C++11中还新增了线程存储，这将在后续文章中介绍。本文主要就自动存储、静态存储和动态存储进行归纳整理。</p>
<h2 id="1-堆和栈">1. 堆和栈</h2>
<h3 id="11-概念">1.1 概念</h3>
<p>在具体介绍三类存储方式之前，我们先明确堆和栈的概念：</p>
<ul>
<li>栈：就像装数据的桶或箱子，它是一种具有<strong>后进先出</strong>性质的数据结构。</li>
<li>堆：一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</li>
</ul>
<h3 id="12-程序的内存分配">1.2 程序的内存分配</h3>
<p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>
1、<strong>栈区（stack）</strong> —— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>
2、<strong>堆区（heap）</strong> —— 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>
3、<strong>全局区（静态区）</strong>（static）—— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>
4、<strong>文字常量区</strong> —— 常量字符串就是放在这里的。程序结束后由系统释放。<br>
5、<strong>程序代码区</strong> —— 存放函数体的二进制代码。</p>
<p>可以根据以下代码进行理解：</p>
<pre><code>int  a=0;   全局初始化区    

char *p1;   全局未初始化区    
int  main()    
{    
  int  b; //栈    
  char  s[]=&quot;abc&quot;; //栈    
  char  *p2; //栈    
  char  *p3=&quot;123456&quot;; //123456/0在常量区，p3在栈上。    

  static int c =0；//全局（静态）初始化区    
  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2  = (char  *)malloc(20);       
  strcpy(p3,&quot;123456&quot;); //123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;  优化成一个地方。    
}    
</code></pre>
<h2 id="2-三种管理数据内存的方式">2. 三种管理数据内存的方式</h2>
<h3 id="21-自动存储">2.1 自动存储</h3>
<p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着他们在所属的函数被调用时自动产生，在该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域为包含它的代码块。</p>
<p>自动变量通常存储在栈中，即：执行该代码块时，其中变量依次加入栈中；而在离开代码块时，将按相反顺序释放这些变量——后进先出（LIFO）。因此，程序执行过程中，栈将不断的增大和缩小。</p>
<h3 id="22-静态存储">2.2 静态存储</h3>
<p>静态存储是整个程序执行期间都存在的存储方式。其数据位于静态存储区（静态区）。使得变量成为静态变量的方式有两种：1）在函数外部定义它；2）使用static关键字声明变量。</p>
<p>自动存储和静态存储的关键在于：其对于变量的寿命限制不同——变量可能存在于程序的的整个生命周期（静态变量）；也可能仅存在于特定函数被执行时（自动变量）。</p>
<p>例如：</p>
<pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
void display();
 
int main()
{
    display();
    display();
    display();
    display();
    display();
     return 0;
}
 
 
void display() {
    static int counter = 0;
    cout &lt;&lt; &quot;display function called &quot; &lt;&lt; ++counter &lt;&lt; &quot; times.&quot; &lt;&lt; endl;
}

/*
输出：
    display function called 1 times.
    display function called 2 times.
    display function called 3 times.
    display function called 4 times.
    display function called 5 times.
*/
</code></pre>
<p>上例说明：当我们在一个函数中声明一个static的变量的时候（即static 为function scope），那么这个静态变量的 lifetime将开始于函数第一次调用开始， 一直到这个Program 运行结束。即函数中的声明并初始化的static变量只执行一次， 无论在Program调用多少次， 都只执行一次， 并该变量保存在heap中。 发生修改就可以保存。</p>
<h3 id="23-动态存储">2.3 动态存储</h3>
<p><strong>new</strong>和<strong>delete</strong>运算符提供了一个比自动变量和静态变量更灵活的方法。其管理一个内存池，在C++中被称为自由存储空间（free store）或 堆（heap）。<strong>该内存池同用于静态变量和动态变量的内存是分开的</strong>。</p>
<p>new和delete使得程序员对变量寿命有更多控制权，甚至可以在一个函数中分配内存，而在另一个函数中释放。因此，数据的生命周期不完全受程序或函数的生存时间控制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机网络：TCP协议的三次握手 & 四次挥手]]></title>
        <id>https://mocuishle0.github.io/post/ji-suan-ji-wang-luo-tcp-xie-yi-de-san-ci-wo-shou-and-si-ci-hui-shou/</id>
        <link href="https://mocuishle0.github.io/post/ji-suan-ji-wang-luo-tcp-xie-yi-de-san-ci-wo-shou-and-si-ci-hui-shou/">
        </link>
        <updated>2020-06-07T01:38:50.000Z</updated>
        <summary type="html"><![CDATA[<p>上一次接触计算机网络相关知识还是本科阶段学习计网课程，此次为了准备相关面试，还是需要把这部分知识好好整理一下......</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一次接触计算机网络相关知识还是本科阶段学习计网课程，此次为了准备相关面试，还是需要把这部分知识好好整理一下......</p>
<!-- more -->
<p>计算机网络部分最容易考到的便是TCP协议的**“三次握手”<strong>和</strong>“四次挥手”**，在网上也看到了许多形象的解读，在此做一归纳：</p>
<h2 id="1-tcpip协议">1. TCP/IP协议</h2>
<p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，<strong>通常被认为是一个四层协议系统，与OSI的七层模型相对应</strong>。</p>
<p>HTTP（HyperText Transfer Protocol），超文本传输协议，是互联网上应用最广泛的一种网络协议，所有www文件都必须遵守的一个标准，是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。简而言之，<strong>HTTP协议就是基于TCP/IP协议模型来传输信息的</strong>。</p>
<p><strong>TCP/IP四层模型：</strong></p>
<ul>
<li><strong>链路层</strong>：也称作数<strong>据链路层或网络接口层</strong>（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
<li><strong>网络层</strong>： 也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
<li><strong>传输层</strong>：主要为两台主机上的应用程序提供端到端的通信。<strong>在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）</strong>。TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。</li>
<li><strong>应用层</strong>：应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。</li>
</ul>
<h2 id="2-tcp三次握手">2. TCP三次握手</h2>
<p>先给一个更便于理解的示例：<br>
<img src="https://mocuishle0.github.io//post-images/1591494923826.webp" alt="" loading="lazy"></p>
<ul>
<li>客户端A：你好服务器，我是客户端A；</li>
<li>服务器B：你好客户端A，我是服务器B；</li>
<li>客户端A：你好，服务器B。</li>
</ul>
<p>官方描述：</p>
<ul>
<li><strong>第一次握手</strong>：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；【SYN：同步序列编号（Synchronize Sequence Numbers）】</li>
<li><strong>第二次握手</strong>：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li><strong>第三次握手</strong>：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<p>完成三次握手，客户端与服务器开始传送数据。这样就保证了，每次传送数据都会准确到达目标设备了。</p>
<h2 id="3-tcp四次挥手">3. TCP四次挥手</h2>
<p>还是先给出一个更便于理解的示例：</p>
<ul>
<li>主动结束方：你好，我的数据发送完毕了，我要进入准备断开的状态了。（此时它虽然不再发送数据了，但是可以接受数据）</li>
<li>另一方：我知道了，我还没有发送完毕的，你等着吧。</li>
<li>另一方：我也发送完毕了，可以断开链接了。（此时它也进入准备断开的状态）</li>
<li>主动结束方：好的，那断开吧</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1591495364320.webp" alt="" loading="lazy"></figure>
<p>官方描述：</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li>
</ul>
<h2 id="4-为什么tcp建立链接是三次关闭链接是四次呢">4. 为什么TCP建立链接是三次，关闭链接是四次呢？</h2>
<p>其实也不难理解，因为服务端的listen状态下的socket当收到SYN报文的建连请求后，<strong>它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送</strong>。但关闭连接时，当收到对方的FIN报文通知时，<strong>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</strong>。</p>
<p>通过TCP协议使得两台设备成功链接，并成功发送了数据，接下来，就需要服务器端来处理数据了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的emplace成员]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-emplace-cheng-yuan/">
        </link>
        <updated>2020-06-06T03:26:02.000Z</updated>
        <summary type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>老问题，但还有更优雅的做法。</p>
<!-- more -->
<p>在右值引用和移动语义部分，其实我们的核心在于减少了程序运行中对变量的拷贝次数（这仅是个人直观的理解）。其实在C++11的容器中，还有一种优雅的方式可以达到这一目的。</p>
<h2 id="1-引例">1. 引例</h2>
<p>考虑下面的Rect类：</p>
<pre><code>struct Rect
{
    Rect(int l, int t, int r, int b)
        :left{l}, top{t}
        ,right{r}, bottom{b}
    {}
    int left;
    int top;
    int right;
    int bottom;
};
</code></pre>
<p>如果我们需要向容器添加Rect对象时，代码大致是这样的：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.push_front(Rect(10, 10, 20, 20));
</code></pre>
<p>在调用push_front时，首先构造一个临时的Rect对象传递给push_front方法，然后在push_front的内部，在复制一个Rect对象添加到容器中。全过程会发生一次创建动作和一次拷贝动作，才能将对象的内容添加到list当中去(其他容器同理)。</p>
<h2 id="2-emplace方法">2. emplace方法</h2>
<p>为了减少拷贝动作的次数，当然可以使用右值引用参数的成员函数。除此之外，C++11还提供了另一种方法：emplace成员。<strong>使用这个成员可以直接传递用于生成对象的参数，对象的创建过程交给容器去执行</strong>：</p>
<pre><code>std::list&lt;Rect&gt; rlist;
rlist.emplace_front(10, 10, 20, 20);
</code></pre>
<p>用法非常简单，只要保证参数和元素构造函数的参数相同即可。除了emplace_front以外，C++11还提供了emplace和emplace_bak方法，分别对应insert和push_back方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：右值引用 与 移动语义]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-you-zhi-yin-yong-yu-yi-dong-yu-yi/">
        </link>
        <updated>2020-06-06T00:59:33.000Z</updated>
        <summary type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个新接触到的概念——左值、右值。</p>
<!-- more -->
<p>实话实说，关于左值、右值的概念也是这次整理时才第一次接触到。所以就根据看到的相关资料做一个归纳。</p>
<h2 id="1-左值-右值">1. 左值 &amp; 右值</h2>
<p>在C++表达式的特性中有一个左值和右值的概念。如果一个表达式可以放在<strong>赋值语句</strong>的左侧，就称之为左值，如果不能放到表达式的左侧，就称之为右值。通俗的来讲，<strong>左值（lvalue）是一个表达式，它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址</strong>。如果一个表达式不是左值，那它就被定义为右值。</p>
<pre><code>//赋值操作需要左操作数是一个左值。var 是一个有内存位置的对象，因此它是左值.
int var;
var = 4;

4 = var;       // 错误！
(var + 1) = 4; // 错误！
</code></pre>
<p>在上面的例子中，常量 4 和表达式 var + 1 都不是左值（也就是说，它们是右值），因为它们都是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）。因此，赋值给它们是没有任何语义上的意义的——我们赋值到了一个不存在的位置。</p>
<p>不同的运算符对运算对象的要求各不相同，例如：</p>
<ul>
<li>赋值运算符的左侧要求是左值，得到的结果还是左值，因此我们可以继续对它赋值；</li>
<li>取地址符作用于左值运算对象，返回对象的指针为右值，因此取地址运算表达式只能位于赋值语句的右侧。</li>
</ul>
<h2 id="2-右值引用">2. 右值引用</h2>
<p>在介绍C++11 新引入的右值引用概念之前，我们先介绍一下一般的引用类型。需要注意的是，只有左值可以付给引用，如：</p>
<pre><code>int&amp; ref = 9;   //编译错误
</code></pre>
<p>我们只能这样做：</p>
<pre><code>    int l=9;
    int &amp;r=l;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //9 9

    r++;
    cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;      //10 10
</code></pre>
<p>没有问题，l是左值，所以可以将引用类型的r绑定到l上，今后对r的操作就等同于对l的操作。</p>
<p>C++11引入了右值引用的概念，<strong>使得我们把引用与右值进行绑定。使用两个“取地址符号”</strong>：</p>
<pre><code>int&amp;&amp; rvalue_ref = 99;
</code></pre>
<p>下面的例子更有助于理解：</p>
<pre><code>#include &lt;iostream&gt;

void f(int&amp; i) { std::cout &lt;&lt; &quot;lvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }
void f(int&amp;&amp; i) { std::cout &lt;&lt; &quot;rvalue ref: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;; }

int main()
{
    int i = 77;
    f(i);    // lvalue ref called
    f(99);   // rvalue ref called

    f(std::move(i));  
    
    /*std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对i赋值或销毁以外，不再使用它。*/

    return 0;
}
/*
    输出：
        lvalue ref: 77
        rvalue ref: 99
        lvalue ref: 77
*/
</code></pre>
<p>还存在更为隐晦的右值，如下例：</p>
<pre><code>#include &lt;iostream&gt;

int getValue ()     //getValue()是一个右值
{
    int ii = 10;
    return ii;
}

int main()
{
    const int&amp; val = getValue(); // OK
    int&amp; val = getValue(); // NOT OK

    const int&amp;&amp; val = getValue(); // OK
    int&amp;&amp; val = getValue(); //  OK
    return 0;
}

</code></pre>
<p>因此，对比以下代码，我们可以发现：</p>
<pre><code>void printReference (const int&amp; value)  //可以接受参数为左值，也可以接受右值。 
{
        cout &lt;&lt; value;
}

void printReference (int&amp;&amp; value)   //只能接受右值引用作为参数。
{
        cout &lt;&lt; value;
}
</code></pre>
<h2 id="3-移动语义">3. 移动语义</h2>
<p>了解了右值引用的基本概念后，其实我也很纠结：C++11引入这样一个令人头大的特征到底有什么用？在<a href="https://blog.csdn.net/craftsman1970/article/details/80397276">参考文献</a>中作者的解释其实是挺容易让我理解的：</p>
<h3 id="31-实例演示">3.1 实例演示</h3>
<p>在C++语言中，引用是作为一种高效，安全的传递数据的方式而存在的。除了一般的引用类型，还可以声明const引用。例如，我们有以下一个Image类：</p>
<pre><code>class Image
{
    private:
       int width = 0;
       int height = 0;
       char *data = nullptr;
public:

   Image(int w, int h): width(w), height(h){
       data = new char[getSize()];
    }

   int getSize(){
       return width * height;
    }

   virtual ~Image(){
        if (data != nullptr){
            delete data;
            data = nullptr;
            width = 0;
            height = 0;        
        }  
    }
}
</code></pre>
<p>上面只是这个类的雏形，只有构造函数，析构函数和取得数据大小的功能。接下来添加比较两个Image是否相同的函数。最简单的形式大致如下。</p>
<pre><code>bool isSame(Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        return (memcmp(data,img.data,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里使用引用类型的参数，避免了没有必要的拷贝动作。当然我们还可以做得更好：<strong>由于比较函数没有必要也不应该对比较对象的内容进行修改，所以还可用下面的形式进行承诺</strong>：</p>
<pre><code>bool isSame(const Image&amp; img)
{
    if(width == img.width
      &amp;&amp; height == img.height){
        char* in = static_cast&lt;char*&gt;(img.data);
        return (memcmp(data,in,getSize())==0);
    }
    else{
        return false;
    }
}
</code></pre>
<p>这里，<strong>通过在参数前面增加const修饰符，向isSame方法的调用者保证，不会修改img的内容</strong>。</p>
<hr>
<p>到此为止都是我们所熟悉的内容。然而，如果我们希望继续添加将一个Image的一部分merge到另一个Image上的方法，函数的内容大致如下(这里忽略处理的细节)：</p>
<pre><code>void merge(Image&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>类似的操作在处理在输入对象时一般有两种处理方式。有时希望只是参照而不破坏输入数据，这时可以使用前面讲到的为参数增加const修饰符的方式来承诺；有时为了提高效率或者其他的原因希望可以<strong>接管输入的数据，就像上面代码的状态</strong>。这时的行为更像是数据移动。对于第二种方式，如果仅仅定义一般的引用类型，<strong>利用者根本没有办法通过方法声明来确定这个操作是否会接管参数中的数据。这种不确定性会造成很大的麻烦</strong>。解决这个问题的方法就是利用右值引用：</p>
<pre><code>void merge(Image&amp;&amp; img){
    //接管img中的数据。
    img.height = 0;
    img.width = 0;
    img.data = nullptr;
}
</code></pre>
<p>我们将参数声明为右值引用，要求像一个临时变量一样任性地使用数据。使用这个函数的方法如下：</p>
<pre><code>Image img1(100, 100);
Image img2(100, 200);
img1.merge(std::move(img2));
</code></pre>
<p>注意代码中的std::move，这是标准库中提供的方法，它可以将左值显式转换为右值引用类型，从而告诉编译器，可以像右值（临时变量）一样处理它。同时也意味着接下来除了对img2赋值或销毁以外，不再使用它。C++11通过使用右值引用提供了一种接管数据的标准方法。</p>
<h3 id="32-移动语义的功能">3.2 移动语义的功能</h3>
<p>当一个函数的参数<strong>按值传递</strong>时，这就会进行<strong>拷贝</strong>。当然，编译器懂得如何去拷贝。 而对于我们自定义的类型，我们也许需要提供拷贝构造函数。但是不得不说，拷贝的代价是昂贵的。所以我们需要寻找一个避免不必要拷贝的方法，即C++11提供的移动语义。</p>
<p>实际上，我们在第2部分介绍的右值引用，其主要目的是用于<strong>创建移动构造函数</strong>和<strong>移动赋值运算</strong>。</p>
<p>移动构造函数类似于拷贝构造函数，把类的实例对象作为参数，并创建一个新的实例对象。但是，移动构造函数可以避免内存的重新分配，因为我们知道右值引用提供了一个暂时的对象，而不是进行copy，所以我们可以进行移动。换言之，<strong>在涉及到关于临时对象时，右值引用和移动语义允许我们避免不必要的拷贝</strong>。我们不想拷贝将要消失的临时对象，所以这个临时对象的资源可以被我们用作于其他的对象。<strong>右值就是典型的临时变量，并且他们可以被修改。如果我们知道一个函数的参数是一个右值，我们可以把它当做一个临时存储。这就意味着我们要移动而不是拷贝右值参数的内容</strong>。这就会节省很多的空间。</p>
<p>更详细的解释可参考：<a href="https://www.kancloud.cn/wangshubo1989/new-characteristics/99718">文献</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：array容器]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-array-rong-qi/">
        </link>
        <updated>2020-06-06T00:29:41.000Z</updated>
        <summary type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
]]></summary>
        <content type="html"><![CDATA[<p>STL容器的新成员，更高效的数组。</p>
<!-- more -->
<p>就我个人而言，原生内置数组时常感觉用起来并不十分顺手。一是大小没有管理，二是越界操作没有检查。虽然C/C++也提供了一些解决办法，但总是不够完美。例如下面的代码：</p>
<pre><code>int ary[5];
memset(ary, 0, sizeof(ary));
unsigned int i = 0;
while(i&lt;sizeof(ary)/sizeof(ary[0])){
    ary[i] = i;
    i++;
}
</code></pre>
<p>C++11后，标准库引入了更现代化的数组std::array。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array<strong>不支持添加和删除元素以及改变容器大小的操作</strong>。与内置数组一样，标准库array的大小也是类型的一部分。<strong>当定义一个array时，除了指定元素类型，还要指定容器大小</strong>（array&lt;T,N&gt; 模板定义了一种相当于标准数组的容器类型。它是一个<strong>有 N 个 T 类型元素的固定序列</strong>）。为了使用array类型，我们必须同时指定元素类型和大小。array仅仅是为普通数组添加了一些成员或全局函数，这使得数组能够被当成标准容器来使用。array不能被动态地扩展或压缩。</p>
<p>和标准数组相比，array 容器的额外开销很小，但提供了两个优点：<strong>1）如果使用 at()，当用一个非法的索引访问数组元素时，能够被检测到，因为容器知道它有多少个元素；2）这也就意味着数组容器可以作为参数传给函数，而不再需要单独去指定数组元素的个数。</strong></p>
<p>使用 array 容器类型时，需要在源文件中包含头文件 array。下面展示了如何创建具有 10 个 double 型元素的 array&lt;&gt;，该实例定义了一个 array 容器，却没有为元素指定初始值，那么元素就不会被初始化：</p>
<pre><code>std::array&lt;double,10&gt; arr;
</code></pre>
<p>但是可以如下所示，将它们初始化为 0 或者和默认元素类型等效的值。使用下面语句初始化后，容器中所有的元素都会变为 0.0。</p>
<pre><code>std::array&lt;double,10&gt; arr{};
</code></pre>
<p>当然，当创建 array 容器的实例时，要像创建常规数组那样，对元素进行初始化：</p>
<pre><code>std::array&lt;double, 10&gt; arr {0.5, 1.0, 1.5, 2.0};
</code></pre>
<p>初始化器列表中的 4 个值用于初始化前 4 个元素，其余的元素都将为 0。</p>
<p>回到我们最初的原生内置数组代码，我们可以利用array编写如下代码：</p>
<pre><code>std::array&lt;int, 5&gt; c11ary;
c11ary.fill(0);
unsigned int i = 0;
while(i&lt;c11ary.size()){
    c11ary.at(i) = i;
    i++;
}
</code></pre>
<p>这段代码中:</p>
<ul>
<li>使用fill方法实现了数据填充。</li>
<li>使用size方法取得数组的大小。</li>
<li>虽然at(i)方法实现带有越界检查的读写。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：返回类型后置]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-fan-hui-lei-xing-hou-zhi/">
        </link>
        <updated>2020-06-05T07:46:07.000Z</updated>
        <summary type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
]]></summary>
        <content type="html"><![CDATA[<p>利用返回类型后置可以令一个函数返回值为“auto”</p>
<!-- more -->
<p>除了构造函数和析构函数以外，函数声明都需要明确函数的返回类型，在传统的C或者C++中，函数声明大致是这个样子：</p>
<pre><code>int getSum(int a, int b);
</code></pre>
<p>第一个int就是函数的返回类型，它表明函数的返回值类型为整数。在新的C++11以后，我们也可以这样声明：</p>
<pre><code>auto getSum(int a, int b)-&gt;int;
</code></pre>
<p>在原来放返回值类型的位置写auto，在函数声明结束以后接一个'-&gt;'再跟着写函数的返回值类型。两种方式的效果是一样的。</p>
<hr>
<p><strong>更优雅的用法：</strong></p>
<p>在介绍返回类型后置之前，我们先来再谈一组令人头大的概念：<strong>数组指针</strong>和<strong>指针数组</strong>......（回想起了被指针常量和常量指针支配的恐惧 -_-）</p>
<ul>
<li><strong>数组指针</strong>：可以理解为**“数组的指针”<strong>，即首先这个变量是一个</strong>指针**，其次，“数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
<ul>
<li>e.g：*<em>char (<em>pa)[4];</em></em></li>
<li>pa是一个指针指向一个char [4]的数组，每个数组元素是一个char类型的变量，所以我们不妨可以写成：char[4] (*pa);这样就可以直观的看出pa的指向的类型。（不过在编辑器中不要这么写，因为编译器根本不认识，这样写只是帮助我们理解。）</li>
</ul>
</li>
<li><strong>指针数组</strong>：可以理解为**“指针的数组”<strong>，首先这个变量是一个</strong>数组**，其次，“指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。
<ul>
<li>e.g：*<em>char <em>arr[4] = {&quot;hello&quot;, &quot;world&quot;, &quot;shannxi&quot;, &quot;xian&quot;};</em></em></li>
<li>arr就是定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。</li>
</ul>
</li>
</ul>
<p>P.s：<strong>指针数组和数组指针的形成的根本原因就是运算符的优先级问题</strong>，所以定义变量是一定要注意这个问题，否则定义变量会有根本性差别！</p>
<p>在明白了<strong>数组指针</strong>和<strong>指针数组</strong>的概念后，我们来聊聊返回类型后置的一种优雅的用法：</p>
<p>一般情况下，当函数要返回多个数据时，会选择将数据封装在类（或结构体）中返回，或者直接返回一个指针。这两种方式要么麻烦，要么没有办法取得数据的数量。其实我们真正的需求就是返回一个数组（可以计算维度的）指针。这种方法是存在的：</p>
<blockquote>
<p>e.g:int (*getResultArray(int mode))[10];</p>
</blockquote>
<p>结合数组指针和指针数组的定义，上面的是数组指针还是指针数组呢？应该是<strong>数组指针</strong>。通过上面的形式，声明了一个返回包含10个整数的数组的指针。对于这样一个指针，我们可以像数组一样使用：</p>
<pre><code>auto arr = getResultArray(1);
cout &lt;&lt; sizeof(*arr)/sizeof(**arr) &lt;&lt; endl; //可以正确计算维度。
</code></pre>
<p>我们其实也可以这样做：</p>
<pre><code>typedef int arr10[10];
arr10* getResultArray(int mode)
</code></pre>
<p>C++11增加了返回类型后置以后，我们有了新的选择：</p>
<pre><code>auto getResultArray(int mode)-&gt;int(*)[10]；
</code></pre>
<p>比第一种形式容易理解很多。也不需要自定义类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：容器的cbegin和cend函数 ]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-rong-qi-de-cbegin-he-cend-han-shu/">
        </link>
        <updated>2020-06-05T03:41:53.000Z</updated>
        <summary type="html"><![CDATA[<p>小众的常量迭代器</p>
]]></summary>
        <content type="html"><![CDATA[<p>小众的常量迭代器</p>
<!-- more -->
<p>这个新特征其实是偶尔在别人的总结中看到的，但觉得确实很有趣，就做个记录：</p>
<h2 id="1-需求">1. 需求</h2>
<p>我们一般在使用STL容器时，下面代码是非常常见的：</p>
<pre><code>int sum = 0;
vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator it = v.begin();
while(it != v.end()){
       sum += *it;
       it++;
 }
</code></pre>
<p>但是，如果我们一旦定义容器为常量，就必须注意迭代器也需要声明为常量：</p>
<pre><code>int sum = 0;

//编译错误：原因是定义的vector是const类型，所以迭代器必须也是const类型
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
 }

//正确写法：
const vector&lt;int&gt; cv{1, 2, 3, 4, 5, 6};
vector&lt;int&gt;::const_iterator cit = cv.begin();
while(cit != v.end()){
       sum += *cit;
       cit++;
}
</code></pre>
<p>这显然很麻烦，一个简单的方法是直接使用auto来自动推断迭代器类型（想必大家都更倾向于这样，毕竟...有了auto还要啥自行车）：</p>
<pre><code>auto ait = cv.begin();
while(ait != cv.end()){ 
       sum += *ait;
       ait++;
 }
</code></pre>
<h2 id="2-优势">2. 优势</h2>
<p>但我们也不难想到存在这样一种情形：<strong>数据本身不是const类型，但是从设计的角度来讲有些处理不应该修改该数据</strong>。这时也应该要求const类型的迭代器，以避免数据被意外修改。所以，C++11为此提供了cbegin和cend方法。</p>
<pre><code>vector&lt;int&gt; v{1, 2, 3, 4, 5, 6};
auto ait = v.cbegin();
while(ait != v.cend()){
           sum += *ait;
           *ait = sum;  //编译错误
           ait++;
}
</code></pre>
<p>cbegin()/cend()决定了返回的迭代器类型为const。这时即使vector的类型不是const，也可以防止对该数据的误操作。</p>
]]></content>
    </entry>
</feed>