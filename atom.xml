<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mocuishle0.github.io/</id>
    <title>MoCuishle</title>
    <updated>2020-06-04T07:41:17.537Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mocuishle0.github.io/"/>
    <link rel="self" href="https://mocuishle0.github.io/atom.xml"/>
    <subtitle>我拥有的都是侥幸，
我失去的都是人生。</subtitle>
    <logo>https://mocuishle0.github.io/images/avatar.png</logo>
    <icon>https://mocuishle0.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, MoCuishle</rights>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：Lambda函数与表达式]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-han-shu-yu-biao-da-shi/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-lambda-han-shu-yu-biao-da-shi/">
        </link>
        <updated>2020-06-04T06:47:21.000Z</updated>
        <content type="html"><![CDATA[<p>其实，最开始接触到lambda函数是在关于python匿名函数的教程中。后来在一些资料上也看到了关于C++中匿名函数的用法的相关讲解。那么，借着这次整理C++11新特征的机会，就对C++中的lambda函数进行一下归纳：</p>
<h2 id="1-lambda-函数与表达式">1. Lambda 函数与表达式</h2>
<p>C++11 提供了对匿名函数的支持（即，没有函数名的函数）,称为** Lambda 函数(也叫 Lambda 表达式)**。其作用主要在于，如果代码里面存在大量的小函数，而这些函数一般只被一两处调用，那么不妨将它们重构成Lambda表达式，也就是匿名函数。作用就是当你想用一个函数，但是又不想费神去命名一个函数。</p>
<p>Lambda 表达式本质上与函数声明非常类似，其通用表达形式——$[捕获区] (参数区)-&gt;返回类型 {代码区}：</p>
<ul>
<li><strong>[捕获区]</strong>，指定在可见域范围内lambda表达式代码内可见的参数，即（除了形参之外）它可以使用的变量列表。<strong>在Lambda表达式内可以访问当前作用域的变量</strong>，这是Lambda表达式的闭包（Closure）行为：
<ul>
<li>[]，沒有定义任何变量，即不捕获外部的任何变量。使用未定义变量会引发错误。</li>
<li>[x, &amp;y]，x以传值方式传入（默认），y以引用方式传入。</li>
<li>[&amp;]，任何被使用到的外部变量都隐式地以引用方式加以引用。</li>
<li>[=]，任何被使用到的外部变量都隐式地以传值方式加以引用。</li>
<li>[&amp;, x]，x显式地以传值方式加以引用。其余变量以引用方式加以引用。</li>
<li>[=, &amp;z]，z显式地以引用方式加以引用。其余变量以传值方式加以引用。</li>
<li>[this]，以值的方式捕获 this 指针。</li>
</ul>
</li>
<li><strong>(参数区)</strong>，指定lambda表达式内部变量定义</li>
<li><strong>-&gt;返回类型</strong>，是返回类型，如果 lambda 代码块中包含了 return 语句，则该 lambda 表达式的返回类型由 return 语句的返回类型确定。如果没有 return 语句，则类似 void f(…) 函数。</li>
<li><strong>{代码区}</strong>，是Lambda表达式主题结构。</li>
</ul>
<p>例如：</p>
<pre><code>//通用表达形式：[捕获区](参数区)-&gt;返回类型 {代码区};
int n = [] (int x, int y) { return x + y; }(5, 4);      //n=9
</code></pre>
<p>P.s：Lambda函数通过“函数体”后面的‘()’传入参数，如上例中的（5,4）。</p>
<h2 id="2-使用场景">2. 使用场景</h2>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。就目前来看，Lambda函数最常用的使用场景在于：sort、for_each等自定义比较函数。</p>
<p>下面给出了一个非常具体且完整的Lambda表达式的使用样例，可帮助我们加深理解：</p>
<pre><code>class CTest 
{ 
 public:  
   CTest() : m_nData(20) { NULL; }  
   void TestLambda()  
   {   
     vector&lt;int&gt; vctTemp;   
     vctTemp.push_back(1);   
     vctTemp.push_back(2);    

   // 无函数对象参数，输出：1 2   
   {    
     for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout &lt;&lt; v &lt;&lt; endl; });   
   }   

   // 以值方式传递作用域内所有可见的局部变量（包括this），输出：11 12   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [=](int v){ cout &lt;&lt; v+a &lt;&lt; endl; });   
   }    

   // 以引用方式传递作用域内所有可见的局部变量（包括this），输出：11 13 12   
   {    
     int a = 10;   
     for_each(vctTemp.begin(), vctTemp.end(), [&amp;](int v)mutable{ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;   
   }    

   // 以值方式传递局部变量a，输出：11 13 10   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [a](int v)mutable{ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;   
   }    

   // 以引用方式传递局部变量a，输出：11 13 12   
   {    
     int a = 10;    
     for_each(vctTemp.begin(), vctTemp.end(), [&amp;a](int v){ cout &lt;&lt; v+a &lt;&lt; endl; a++; });    
     cout &lt;&lt; a &lt;&lt; endl;  
   }    

   // 传递this，输出：21 22 
   {  
     for_each(vctTemp.begin(), vctTemp.end(), [this](int v){ cout &lt;&lt; v+m_nData &lt;&lt; endl; });   
   }    

   // 除b按引用传递外，其他均按值传递，输出：11 12 17   
   {    
     int a = 10;    
     int b = 15;    
     for_each(vctTemp.begin(), vctTemp.end(), [=, &amp;b](int v){ cout &lt;&lt; v+a &lt;&lt; endl; b++; });    
     cout &lt;&lt; b &lt;&lt; endl;   
   }     
   // 操作符重载函数参数按引用传递，输出：2 3   
   {    
     for_each(vctTemp.begin(), vctTemp.end(), [](int &amp;v){ v++; });    
     for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout &lt;&lt; v &lt;&lt; endl; });   
   }    
   // 空的Lambda表达式   
   {    
     [](){}();    []{}();   
   }  
 }  
 private:  int m_nData; 
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：nullptr空指针]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-nullptr-kong-zhi-zhen/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-nullptr-kong-zhi-zhen/">
        </link>
        <updated>2020-06-04T03:05:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-空指针">1. 空指针</h2>
<p>在谈nullptr之前，我们先聊聊C++中的空指针：<br>
在指针变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。<strong>NULL 指针是一个定义在标准库中的值为零的常量</strong>。例如：</p>
<pre><code>#include &lt;iostream&gt;
//程序将输出：ptr 的值是 0
using namespace std;

int main ()
{
   int  *ptr = NULL;
   // int *ptr = 0; 

   cout &lt;&lt; &quot;ptr 的值是 &quot; &lt;&lt; ptr ;
 
   return 0;
}
</code></pre>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。如需检查一个空指针，可以使用 if 语句，如下所示：</p>
<pre><code>if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
//个人常用的方式：
if(ptr!=NULL)       /* 如果 ptr 非空，则完成 */
if(ptr==NULL)   /* 如果 ptr 为空，则完成 */
</code></pre>
<p>所以，综上所述，声明一个空指针可有两种方式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mi>p</mi><mo>=</mo><mi>N</mi><mi>U</mi><mi>L</mi><mi>L</mi><mi mathvariant="normal">或</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">int* p = NULL 或 int* p = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">或</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。<br>
此处对<strong>NULL</strong>和<strong>常数0</strong>进行一些整理：</p>
<ul>
<li>NULL到底是什么？NULL的实质是一个在标准库头文件&lt;stddef.h&gt;中定义的宏。</li>
<li>它的值是多少？C/C++标准规定：它的值是一个空指针常量（null pointer constant），由实现定义。</li>
<li>什么样的值才能称之为空指针常量？C语言中常数0和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo>∗</mo><mo>)</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(void*)0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">∗</span><span class="mclose">)</span><span class="mord">0</span></span></span></span>都是空指针常量；C++中（暂且忽略C++11）常数0是，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mi>o</mi><mi>i</mi><mi>d</mi><mo>∗</mo><mo>)</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(void*)0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">∗</span><span class="mclose">)</span><span class="mord">0</span></span></span></span>不是。</li>
</ul>
<p>其实我们查看对NULL的定义即可明白：</p>
<pre><code>if defined(__cplusplus)
define NULL 0    // C++中使用0作为NULL的值
else
define NULL ((void *)0)    // C中使用((void *)0)作为NULL的值
endif
</code></pre>
<h2 id="2-nullptr">2. nullptr</h2>
<p>通过上述介绍，我们不难看出，在编程的世界里0有双重的角色，可以表示整数零，也可以表示一个空指针。在C语言中，通过预编译宏NULL，可以区分0表示的是零还是(void*)0。但是，在C++的世界中，这样是不可以的。加之C++中允许函数重载，这便对空指针的声明产生了影响，例如：</p>
<pre><code>void foo(char *);
void foo(int);
</code></pre>
<p>如果把NULL定义为0，那么foo(NULL)将调用哪个函数呢？</p>
<pre><code>#include &lt;stddef.h&gt;
void foo(int) {}     // #1
void foo(char*) {}   // #2
int main() {
    foo(NULL); // 调用#1还是#2？
}
</code></pre>
<p>从字面上来讲，NULL是个空指针常量，我们可能会觉得：既然是个指针，那么应该调用#2。但事实上调用的却是#1，因为C++中NULL扩展为常数0，它是int型。<br>
为了解决常数0既是整数常量，也是空指针常量这样的二义性问题，C++11引入了另一个关键字nullptr，作为一个空指针。例如：</p>
<pre><code>char *pc = nullptr;     // OK
int  *pi = nullptr;     // OK
bool   b = nullptr;     // OK. b is false.
int    i = nullptr;     // error

foo(nullptr);           // calls foo(char *), not foo(int);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 新特征：auto & decltype类型推导]]></title>
        <id>https://mocuishle0.github.io/post/c11-xin-te-zheng-auto-and-decltype-lei-xing-tui-dao/</id>
        <link href="https://mocuishle0.github.io/post/c11-xin-te-zheng-auto-and-decltype-lei-xing-tui-dao/">
        </link>
        <updated>2020-06-04T01:22:10.000Z</updated>
        <content type="html"><![CDATA[<p>第一次接触到<strong>auto</strong>关键字是无意间看到一行代码简洁优雅地实现了STL容器的迭代器，再看看我写的一长串诸如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>&lt;</mo><mi>i</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mo>:</mo><mo>:</mo><mi>i</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mo>⋯</mo></mrow><annotation encoding="application/x-tex">vector&lt;int&gt;::iterator it\dotsb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span>就默默流下了没有技术的眼泪😂。这次想到要整理C++11新特性，就先来谈谈这个<strong>auto</strong>关键字以及与其功能相似的<strong>decltype</strong>关键字：</p>
<h2 id="1-auto关键字">1. auto关键字</h2>
<h3 id="11-auto简介">1.1 auto简介</h3>
<p>在C++11标准中，<strong>auto</strong>关键字的功能为自动类型推断。<strong>auto</strong>关键字的功能其实并不难理解，简而言之，就是<strong>让编译器根据变量的初值去自动推导这个变量的类型</strong>。<br>
<strong>auto</strong>现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。各种作用域内声明变量都可以用到它。例如，名空间中，程序块中，或是for循环的初始化语句中。例如以下代码：</p>
<pre><code>auto i = 42;        // i is an int
auto d=23.3;        //d is a double
auto l = 42LL;      // l is a long long
</code></pre>
<p>正如之前所说，auto最常见的用法是用来声明STL容器的迭代器。不得不说，正规的迭代器声明实在是太长了，例如：</p>
<pre><code>using namespace std;
//...
vector&lt;int&gt; vec(3);
vector&lt;int&gt;::iterator it;
for(it=vec.begin();it!=vec.end();it++){
    //...
}
</code></pre>
<p>然而，如果我们使用auto关键字，代码会简洁很多：</p>
<pre><code>using namespace std;
//...
vector&lt;int&gt; vec(3);
for(auto it=vec.begin();it!=vec.end();it++){
    //...
}
</code></pre>
<h3 id="12-auto效率">1.2. auto效率</h3>
<p>auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响。另外，auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。</p>
<h3 id="13-注意事项">1.3. 注意事项</h3>
<p>auto关键字虽然很简单，使用也很方便，但其在使用中仍有以下几点事项需要注意：</p>
<ul>
<li>auto声明的变量必须要初始化，否则编译器不能判断变量的类型。</li>
<li>auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数。但是，<strong>如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置</strong>。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。下面给出一个经典的例子，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型：</li>
</ul>
<pre><code>template &lt;typename _Tx, typename _Ty&gt;
auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx + _Ty)    //decltype用法见后文
{
    return x + y;
}
auto v = compose(2, 3.14);  // v's type is double
</code></pre>
<h2 id="2-decltype关键字">2. decltype关键字</h2>
<p>其实我也是在查询auto关键字时，第一次接触到<strong>decltype</strong>关键字。编译时类型推导的出现主要是为了泛型编程，因为在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导。而编译时类型推导，除了上面介绍的auto关键字，还有decltype关键字。以下对<strong>decltype</strong>的用法进行整理：</p>
<h3 id="21-decltype用法">2.1 decltype用法</h3>
<p>decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，<strong>而是以一个普通表达式作为参数，返回该表达式的类型，而且decltype并不会对表达式进行求值</strong>。例如：</p>
<pre><code>int i = 4;
decltype(i) a;      //推导结果为int。a的类型为int。
using size_t = decltype(sizeof(0));     //using此处用于定义别名,sizeof(a)的返回值为size_t类型
</code></pre>
<p>同样地，decltype也可以用于声明STL容器的迭代器：</p>
<pre><code>vector&lt;int &gt;vec;
    typedef decltype(vec.begin()) vectype;
    for (vectype i = vec.begin; i != vec.end(); i++)
    {
        //...
    }
</code></pre>
<p>此外，在C++中，我们有时候会遇上一些匿名类型，而借助decltype，我们可以重新使用这个匿名的结构体：</p>
<pre><code>struct 
{
    int d ;
    doubel b;
}anon_s;

decltype(anon_s) as ;//定义了一个上面匿名的结构体
</code></pre>
<p>而decltype最大的用途是在泛型编程中结合auto，用于追踪函数的返回值类型。（参考auto中最后一个示例代码）。</p>
<h3 id="22-decltype推导四规则仅作了解">2.2 decltype推导四规则（仅作了解）</h3>
<ol>
<li>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。</li>
<li>否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp;</li>
<li>否则，假设e的类型是T，如果e是一个左值（左值就是在赋值中可以放在赋值操作符两边的值，一切变量都是左值，但const变量是例外），那么decltype（e）为T&amp;。</li>
<li>否则，假设e的类型是T，则decltype（e）为T。</li>
</ol>
<p>如下面的例子，仅仅为i加上了()，就导致类型推导结果的差异。这是因为，i是一个标记符表达式，根据推导规则1，类型被推导为int。而(i)为一个左值表达式，所以类型被推导为int&amp;。</p>
<pre><code>int i=10;
decltype(i) a; //a推导为int
decltype((i))b=i;//b推导为int&amp;，必须为其初始化，否则编译错误
</code></pre>
<p>具体内容可参考：<a href="https://www.cnblogs.com/QG-whz/p/4952980.html">decltype用法</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACM专题：字符串匹配算法]]></title>
        <id>https://mocuishle0.github.io/post/acm-zhuan-ti-zi-fu-chuan-pi-pei-suan-fa/</id>
        <link href="https://mocuishle0.github.io/post/acm-zhuan-ti-zi-fu-chuan-pi-pei-suan-fa/">
        </link>
        <updated>2020-06-02T09:01:26.000Z</updated>
        <summary type="html"><![CDATA[<p>字符串匹配问题，无论是编程课还是算法课都会被提及，就连公司笔试、面试也都是热点问题之一。可是奈何当时学习时对于该问题的算法理解并不到位，特此进行总结归纳。<br>
P.s：以下内容主要是对公众号：“程序员小灰”中字符串匹配专题的整理加上自己的理解。<a href="https://mp.weixin.qq.com/s/67uf7pRxXh7Iwm7MMpqJoA">原文参考</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>字符串匹配问题，无论是编程课还是算法课都会被提及，就连公司笔试、面试也都是热点问题之一。可是奈何当时学习时对于该问题的算法理解并不到位，特此进行总结归纳。<br>
P.s：以下内容主要是对公众号：“程序员小灰”中字符串匹配专题的整理加上自己的理解。<a href="https://mp.weixin.qq.com/s/67uf7pRxXh7Iwm7MMpqJoA">原文参考</a></p>
<!-- more -->
<p>本文概要：</p>
<ul>
<li>问题定义</li>
<li>BF算法（暴力求解）</li>
<li>RK算法</li>
<li>BM算法</li>
<li>KMP算法</li>
</ul>
<h2 id="1-问题定义">1. 问题定义</h2>
<p>所谓字符串匹配问题，即给定一个字符串A（称：“主串”）和一个字符串B（称：“模式串”），我们需要找出模式串在主串中第一次出现的位置，若模式串未在主串中出现，则返回-1。<br>
举一个例子：<br>
<img src="https://mocuishle0.github.io//post-images/1591089180883.webp" alt="" loading="lazy"><br>
在上图中，字符串B是A的子串，B第一次在A中出现的位置下标是2（字符串的首位下标是0），所以返回 2。<br>
而在下面的例子中：<br>
<img src="https://mocuishle0.github.io//post-images/1591089220552.png" alt="" loading="lazy"><br>
字符串B在A中并不存在，所以返回 -1。</p>
<h2 id="2-bf算法暴力求解">2. BF算法（暴力求解）</h2>
<p>Brute Force（暴力算法）的想法其实无须多言，即：遍历主串每一位字符，尝试从头匹配模式串。若与当前主串字符与模式串字符匹配，则尝试用主串中下一位字符去匹配模式串的下一位字符；否则，用主串下一位字符尝试从头匹配模式串。<br>
<strong>实例如下</strong>：<br>
第一轮，我们从主串的首位开始，把主串和模式串的字符逐个比较。<br>
<img src="https://mocuishle0.github.io//post-images/1591089560847.png" alt="" loading="lazy"><br>
显然，主串的首位字符是a，模式串的首位字符是b，两者并不匹配。</p>
<p>第二轮，我们把模式串后移一位，从主串的第二位开始，把主串和模式串的字符逐个比较<br>
<img src="https://mocuishle0.github.io//post-images/1591089608610.png" alt="" loading="lazy"><br>
主串的第二位字符是b，模式串的第二位字符也是b，两者匹配，继续比较：<br>
<img src="https://mocuishle0.github.io//post-images/1591089629905.png" alt="" loading="lazy"><br>
主串的第三位字符是b，模式串的第三位字符也是c，两者并不匹配。<br>
...<br>
重复上述过程，直到找到模式串第一次出现位置，或将主串遍历完毕。</p>
<p>显然，BF算法最大的问题在于对于某些极端情况处理效率极低，如下：<br>
<img src="https://mocuishle0.github.io//post-images/1591089744915.png" alt="" loading="lazy"><br>
上图的情况，在每一轮进行字符匹配时，模式串的前三个字符a都和主串中的字符相匹配，一直检查到模式串最后一个字符b，才发现不匹配。这样一来，两个字符串在每一轮都需要白白比较4次，显然非常浪费。假设主串的长度是m，模式串的长度是n，那么在这种极端情况下，BF算法的最坏时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="3-rk算法rabin-karp">3. RK算法（Rabin-Karp）</h2>
<p>RK算法的核心在于<strong>使用哈希散列处理字符串，进而比较两个字符串的哈希值</strong>。其实质可看作是对于字符串的一个编码过程。<br>
如果熟悉哈希表的话我们可知，每一个字符串都可以通过某种哈希算法，转换成一个整型数，这个整型数就是hashcode：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>=</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">hashcode = hash(string)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span><br>
<img src="https://mocuishle0.github.io//post-images/1591090031037.webp" alt="" loading="lazy"><br>
显然，相对于逐个字符比较两个字符串，仅比较两个字符串的hashcode要容易得多。</p>
<p>RK算法流程如下：<br>
给定主串和模式串如下（假定字符串只包含26个小写字母）：<br>
<img src="https://mocuishle0.github.io//post-images/1591090083179.png" alt="" loading="lazy"><br>
第一步，<strong>我们需要生成模式串的hashcode</strong>。生成hashcode的算法多种多样，比如：按位相加——这是最简单的方法，我们可以把a当做1，b当做2，c当做3......然后把字符串的所有字符相加，相加结果就是它的hashcode。如：</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>c</mi><mi>e</mi><mo>=</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>10</mn><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">bce =  2 + 3 + 5 = 10。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord cjk_fallback">。</span></span></span></span></p>
</blockquote>
<p>但是，这个算法虽然简单，却很可能产生hash冲突，比如bce、bec、cbe的hashcode是一样的。<br>
因此，我们不妨考虑将字符串转换成26进制数，既然字符串只包含26个小写字母，那么我们可以把每一个字符串当成一个26进制数来计算。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>c</mi><mi>e</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mo>(</mo><mn>2</mn><msup><mn>6</mn><mn>2</mn></msup><mo>)</mo><mo>+</mo><mn>3</mn><mo>∗</mo><mn>26</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>1435</mn></mrow><annotation encoding="application/x-tex">bce = 2*(26^2) + 3*26 + 5 = 1435</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span></span></span></span></p>
</blockquote>
<p>这样做的好处是大幅减少了hash冲突，缺点是计算量较大，而且有可能出现超出整型范围的情况，需要对计算结果进行取模。为了方便演示，后续我们采用的是按位相加的hash算法，所以bce的hashcode是10：<br>
<img src="https://mocuishle0.github.io//post-images/1591090287246.png" alt="" loading="lazy"></p>
<p>第二步，<strong>生成主串当中第一个等长子串的hashcode</strong>。由于主串通常要长于模式串，把整个主串转化成hashcode是没有意义的，只有比较主串当中和模式串等长的子串才有意义。因此，我们首先生成主串中第一个和模式串等长的子串hashcode，即abb = 1 + 2 + 2 = 5：<br>
<img src="https://mocuishle0.github.io//post-images/1591090346395.webp" alt="" loading="lazy"></p>
<p>第三步，<strong>比较两个hashcode</strong>。显然，5！=10，说明模式串和第一个子串不匹配，我们继续下一轮比较。</p>
<p>第四步，<strong>生成主串当中第二个等长子串的hashcode</strong>。bbc = 2 + 2 + 3 = 7：<br>
<img src="https://mocuishle0.github.io//post-images/1591090391409.png" alt="" loading="lazy"><br>
...<br>
重复以上过程。我们发现，当生成主串当中第三个等长子串的hashcode时，bce= 2 + 3 + 5 = 10：<br>
<img src="https://mocuishle0.github.io//post-images/1591090454534.png" alt="" loading="lazy"><br>
显然，10 ==10，两个hash值相等！这是否说明两个字符串也相等呢？别高兴的太早，<strong>由于存在hash冲突的可能，我们还需要进一步验证</strong>。<br>
第五步，<strong>逐个字符比较两字符串</strong>。hashcode的比较只是初步验证，之后我们还需要像BF算法那样，对两个字符串逐个字符比较，最终判断出两个字符串匹配。最后得出结论，模式串bce是主串abbcefgh的子串，第一次出现的下标是2。</p>
<p>通过以上过程，我们不难发现，RK算法本质类似于BF算法，只不过是将字符串的比较转化为先通过哈希值的比较，后进行验证的策略。可能我们会想：每次hash的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，若将全部子串进行hash，最终时间复杂度仍为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，这与BF算法相同。<br>
然而，需要注意的是，每次对主串中的子串进行hash的过程并不独立：我们可以根据前一子串的hashcode进行简单的加减运算即可得到后一子串的hashcode。<br>
综上，由于RK算法计算单个子串hash时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，后续子串是增量计算所以整体复杂度仍为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>此外，我们不难想到，由于RK算法核心是使用哈希值，因此该算法的缺点在于哈希冲突。每次哈希冲突（即主串的子串哈希值与模式串相等）时，就需要逐个字符比对，这在极端情况下将退化为BF算法。</p>
<h2 id="4-bm算法">4. BM算法</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ACM专题：最长回文子串]]></title>
        <id>https://mocuishle0.github.io/post/acm-zhuan-ti-zui-chang-hui-wen-zi-chuan/</id>
        <link href="https://mocuishle0.github.io/post/acm-zhuan-ti-zui-chang-hui-wen-zi-chuan/">
        </link>
        <updated>2020-06-02T02:33:57.000Z</updated>
        <summary type="html"><![CDATA[<p>最长回文子串问题，是ACM题库或各大公司笔试/面试中一类经典的问题。该问题在本科阶段的学习中就屡次被提及，但当时并未完全理解。此次对该问题进行一次整理与归纳。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最长回文子串问题，是ACM题库或各大公司笔试/面试中一类经典的问题。该问题在本科阶段的学习中就屡次被提及，但当时并未完全理解。此次对该问题进行一次整理与归纳。</p>
<!-- more -->
<p>本文概要：</p>
<ul>
<li>问题定义</li>
<li>求解思路：
<ul>
<li>暴力求解</li>
<li>动态规划求解</li>
<li>中心扩散法</li>
<li>Manacher 算法</li>
</ul>
</li>
</ul>
<h2 id="1-问题定义">1. 问题定义：</h2>
<p><strong>定义 1.1 回文串：</strong> 是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。（百度百科）<br>
<strong>定义 1.2 最长回文子串：</strong> 最长回文子串或最长对称因子问题是在一个字符串中查找一个最长的连续的回文的子串，例如“banana”最长回文子串是“anana”。最长回文子串并不一定是唯一的，比如“abracadabra”，没有超过3的回文子串，但是有两个回文字串长度都是3：“ada”和“aca”。</p>
<p><strong>示例 1：</strong><br>
输入: &quot;babad&quot;<br>
输出: &quot;bab&quot;<br>
注意: &quot;aba&quot; 也是一个有效答案。</p>
<p><strong>示例 2:</strong><br>
输入: &quot;cbbd&quot;<br>
输出: &quot;bb&quot;</p>
<h2 id="2-求解思路">2. 求解思路：</h2>
<h3 id="21-暴力求解brute-force">2.1 暴力求解（Brute Force）</h3>
<p>直观地，我们可以穷举给定字符串s中全部子串，继而判断当前子串是否符合回文串定义。在所有回文串中找到长度最长的即可。<br>
值得注意的是，在具体实现过程中，我们通过以下技巧来提高算法的效率：</p>
<ul>
<li>在具体实现时，可以只针对长度大于“当前得到的最长回文子串长度”的子串进行“回文验证”；</li>
<li>在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。</li>
</ul>
<p>参考代码如下：</p>
<pre><code>//暴力求解法：
int maxL = 0;
string resStr;
for (int i = 0; i &lt; s.length(); i++)
{
    string str;
    for (int j = i; j &lt; s.length(); j++)
    {
        str += s[j];
        string rstr = str;

        if (maxL &lt; str.length())
        {
            reverse(rstr.begin(), rstr.end());
            if (str == rstr){
                maxL = str.length();
                resStr = str;
            }
        }

    }
}

cout &lt;&lt; resStr &lt;&lt; endl;
</code></pre>
<p><strong>复杂性分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中N表示给定字符串s的长度。（两重循环+字符串逆序）</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。（只记录“当前子串的起始位置”和“子串长度”）</li>
</ul>
<blockquote>
<p>暴力解法时间复杂度高，但是思路清晰、编写简单。因此，可以使用暴力匹配算法检验我们编写的其它算法是否正确。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p>
</blockquote>
<h3 id="22-动态规划dynamic-programming">2.2 动态规划（Dynamic programming）</h3>
<p>动态规划是算法中一类最基础，同时也是最重要的解题思路之一。判断一个问题是否可以通过动态规划方法求解的核心在于：<strong>判读问题是否具有最优子结构性质，即问题的最优解由相关子问题的最优解组合而成，且子问题可单独求解</strong>。此处推荐算法领域的经典书籍《算法导论》以及北京航空航天大学童咏昕教授的《算法设计与分析》课程（中国大学MOOC）。<br>
就我本人的理解而言，动态规划方法其本质类似于自动机，即后一状态需参考前一状态（或前多个状态）进行状态转移。在这一过程中，问题核心在于发现状态间转换关系，以及如何实现状态转移。LeetCode中的大神也对动态规划进行了总结（<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">参考文献</a>），见下图：<br>
<img src="https://mocuishle0.github.io//post-images/1591067828997.png" alt="" loading="lazy"></p>
<p>就最长回文子串问题而言，我们不难发现，对于给定字符串s的任意长度大于2的子串s[i][j]（从位置i到位置j构成的子串），其是否为回文子串存在以下关系：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是回文串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext></mrow><annotation encoding="application/x-tex">\iff</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span></span></span> 字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]=s[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>且子串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i+1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>是回文串；</li>
</ul>
<p>因此，我们不难得出该问题的动态规划方法：</p>
<ul>
<li>
<p><strong>1）初始化</strong>：初始化一个N*N的矩阵（二维数组）用于表示子串s[i][j]是否为回文串，其中：由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\leq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，因此该矩阵为上三角矩阵，且对角线元素均为<strong>true</strong>。</p>
</li>
<li>
<p><strong>2）递推公式</strong>：</p>
<ul>
<li>首先，如果子串s[i][j]中的首末字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">≠</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]\neq s[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，则s[i][j]可直接判定为<strong>false</strong>；</li>
<li>之后，需要判断子串s[i][j]除去首末字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">、</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]、s[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>后是否构成区间：
<ul>
<li>若不构成区间，即：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>−</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>&lt;</mo><mn>2</mn><mo>←</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo>&lt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">(j-1)-(i+1)+1 &lt; 2\leftarrow j-i &lt; 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>：则s[i][j]可判定为<strong>true</strong>；</li>
<li>若构成区间，即$ j-i \geq 3$：则s[i][j]的结果取决于则s[i+1][j-1]。</li>
<li>注意：每次判定子串s[i][j]是否为回文串后，需再次判断该回文串长度是否大于当前最长回文串长度。若超过当前最长则需要更新。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>3）计算顺序</strong>：<br>
该问题的计算顺序是又一难点。不同于一般的动态规划问题：从左至右、从上至下依次根据前一状态计算后一状态，根据该问题的递推公式可知：当前状态（s[i][j]）取决于矩阵中其左下角状态（s[i+1][j-1]）。因此，我们给出该问题两种错误的计算顺序和四种正确的计算顺序：<br>
<img src="https://mocuishle0.github.io//post-images/1591069534676.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1591069540322.png" alt="" loading="lazy"></p>
</li>
</ul>
<p>参考代码如下：</p>
<pre><code>int slen = s.length();
int maxLen = 1;
int begin = 0;

if (slen &lt; 2)
{
    cout &lt;&lt; s &lt;&lt; endl;
}

bool dp[slen][slen];

memset(dp, 0, sizeof(dp));

for (int i = 0; i &lt; slen; i++)
{
    dp[i][i] = true;
}

for (int j = 1; j &lt; slen; j++)
{
    for (int i = 0; i &lt; j; i++)
    {
        if (s[i] != s[j])
        {
            dp[i][j] = false;
        }
        else
        {
            if (j - i &lt; 3) //区间判断：(j-1)-(i+1)+1&lt;2 =&gt; j-i&lt;3
            {
                dp[i][j] = true;
            }
            else
            {
                dp[i][j] = dp[i + 1][j - 1];
            }
        }

        if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen)
        {
            maxLen = j - i + 1;
            begin = i;
        }
    }
}

cout &lt;&lt; s.substr(begin, maxLen) &lt;&lt; endl;
</code></pre>
<p><strong>复杂性分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>;</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（二维数组）;</li>
</ul>
<p><strong>小结（<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">参考</a>）：</strong></p>
<ul>
<li>我们看到，用「动态规划」方法解决问题，有的时候并不是直接面向问题的。</li>
<li>「动态规划」依然是「空间换时间」思想的体现，并且本身「动态规划」作为一种打表格法，就是在用「空间」换「时间」。</li>
<li>关于「动态规划」方法执行时间慢的说明：
<ul>
<li>动态规划本质上还是「暴力解法」，因为需要枚举左右边界，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>这么多；</li>
<li>以下提供的「中心扩散法」枚举了所有可能的回文子串的中心，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>这么多，不在一个级别上。</li>
</ul>
</li>
</ul>
<h3 id="23-中心扩散法">2.3 中心扩散法</h3>
<p>中心扩散法其实质是对于朴素的暴力求解法的一种优化：朴素的暴力求解是对于子串左右边界的枚举，而根据回文子串的特性我们不难想到，<strong>可对回文“中心位置”进行枚举，并以“中心位置”为中心尝试向左右扩散以得到最长回文子串</strong>。</p>
<p>综上，中心扩散法的思路是：遍历每一个可能的中心位置，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。枚举“中心位置”时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，从“中心位置”扩散得到“回文子串”的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。因此，中心扩散法时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>该方法理解起来并不困难，然而该方法的核心在于如何有效遍历两类回文中心：</p>
<ul>
<li><strong>奇数回文串</strong>的“中心”是一个具体的字符，例如：回文串 &quot;aba&quot; 的中心是字符 &quot;b&quot;；</li>
<li><strong>偶数回文串</strong>的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 &quot;abba&quot; 的中心是两个 &quot;b&quot; 中间的那个“空隙”。<br>
如下图所示：<br>
<img src="https://mocuishle0.github.io//post-images/1591085916365.png" alt="" loading="lazy"><br>
因此，可能成为“中心位置”的候选位置如下所示：<br>
<img src="https://mocuishle0.github.io//post-images/1591085971415.png" alt="" loading="lazy"></li>
</ul>
<p>考虑以上情况，参考代码实现如下（<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">原文</a>）：</p>
<pre><code>string centerSpread(string s, int left, int right) {
        // left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数
        // right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数
        int size = s.size();
        int i = left;
        int j = right;
        while (i &gt;= 0 &amp;&amp; j &lt; size) {
            if (s[i] == s[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j
        return s.substr(i + 1, j - i - 1);
    }

string longestPalindrome(string s) {
        // 特判
        int size = s.size();
        if (size &lt; 2) {
            return s;
        }

        int maxLen = 1;
        string res = s.substr(0, 1);

        // 中心位置枚举到 len - 2 即可
        for (int i = 0; i &lt; size - 1; i++) {
            string oddStr = centerSpread(s, i, i);
            string evenStr = centerSpread(s, i, i + 1);
            string maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr;
            if (maxLenStr.length() &gt; maxLen) {
                maxLen = maxLenStr.size();
                res = maxLenStr;
            }
        }
        return res;
    }

</code></pre>
<h3 id="24-manacher-算法">2.4 Manacher 算法</h3>
<p>Manacher 算法其时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，然而其本身较为复杂。以下仅是自己的理解综合<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">参考文献</a>进行的归纳。</p>
<p>Manacher 算法其核心类似于著名的字符串匹配问题中的KMP算法：<strong>基于中心扩展算法，在下一次扩展时充分利用上一次扩展中的可用信息</strong>。<br>
在介绍Manacher 算法具体流程之前，需要引入<strong>臂长</strong>的概念。所谓臂长，即表示中心扩展算法向外扩展的长度。如果一个位置的最大回文字符串长度为 2 * L + 1 ，其臂长为 L。以Leetcode中的示例为例：给定字符串s=&quot;ebabababe&quot;，对于位置j=4（s[j]=s[4]='a'）而言，其臂长L=4:<br>
<img src="https://mocuishle0.github.io//post-images/1591087759158.png" alt="" loading="lazy"></p>
<p>Manacher 算法其出发点在于，从位置为i的位置进行中心扩展，能否借助之前得到的位置为j的中心扩展中的信息。答案是肯定的。具体来说，如果位置 j 的臂长为L，并且有 j + L &gt; i，如下图所示：<br>
<img src="https://mocuishle0.github.io//post-images/1591087888404.png" alt="" loading="lazy"><br>
当在位置 i 开始进行中心拓展时，我们可以先找到 i 关于 j 的对称点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>2</mn><mo>∗</mo><mi>j</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">i&#x27;=2 * j - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。那么如果点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>的臂长等于 n，我们就可以知道，点 i 的臂长至少为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>j</mi><mo>+</mo><mi>L</mi><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">min(j + L - i, n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。那么我们就可以直接跳过 i 到 i + min(j + L - i, n) 这部分，从 i + min(j + L - i, n) + 1 开始拓展。</p>
<p>以上图为例，j=4,L=4：<br>
若i=6，可知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i&#x27;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>的臂长n=1。由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>j</mi><mo>+</mo><mi>L</mi><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">min(j + L - i, n)=min(2,1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以我们就可以直接跳过 i=6 到 i + min(j + L - i, n) =7 这部分，从位置 i + min(j + L - i, n) + 1 =8 开始拓展。</p>
<p>显然，以上的处理仅针对字符串长度为奇数。而对于字符串长度为偶数的情况，我们可以通过一个简单的小技巧即可完成两种情况的统一：我们向字符串的头尾以及每两个字符中间添加一个特殊字符 #，比如字符串 aaba 处理后会变成 #a#a#b#a#。那么原先长度为偶数的回文字符串 aa 会变成长度为奇数的回文字符串 #a#a#，而长度为奇数的回文字符串 aba 会变成长度仍然为奇数的回文字符串 #a#b#a#，我们就不需要再考虑长度为偶数的回文字符串了。</p>
<p>参考代码如下：</p>
<pre><code>int expand(const string&amp; s, int left, int right) {
        while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) {
            --left;
            ++right;
        }
        return (right - left - 2) / 2;
    }

    string longestPalindrome(string s) {
        int start = 0, end = -1;
        string t = &quot;#&quot;;
        for (char c: s) {
            t += c;
            t += '#';
        }
        t += '#';
        s = t;

        vector&lt;int&gt; arm_len;
        int right = -1, j = -1;
        for (int i = 0; i &lt; s.size(); ++i) {
            int cur_arm_len;
            if (right &gt;= i) {
                int i_sym = j * 2 - i;
                int min_arm_len = min(arm_len[i_sym], right - i);
                cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);
            }
            else {
                cur_arm_len = expand(s, i, i);
            }
            arm_len.push_back(cur_arm_len);
            if (i + cur_arm_len &gt; right) {
                j = i;
                right = i + cur_arm_len;
            }
            if (cur_arm_len * 2 + 1 &gt; end - start) {
                start = i - cur_arm_len;
                end = i + cur_arm_len;
            }
        }

        string ans;
        for (int i = start; i &lt;= end; ++i) {
            if (s[i] != '#') {
                ans += s[i];
            }
        }
        return ans;
    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图算法：多源最短路径问题——Floyd算法]]></title>
        <id>https://mocuishle0.github.io/post/tu-suan-fa-duo-yuan-zui-duan-lu-jing-wen-ti-floyd-suan-fa/</id>
        <link href="https://mocuishle0.github.io/post/tu-suan-fa-duo-yuan-zui-duan-lu-jing-wen-ti-floyd-suan-fa/">
        </link>
        <updated>2020-05-29T01:53:16.000Z</updated>
        <summary type="html"><![CDATA[<p>之前，我们介绍了单源最短路径问题：Dijkstra算法——解决正权边图上的单源最短路径；Bellman-Ford算法——解决图上带负权边的单源最短路径问题。而今天，我们将主要介绍一种解决图上多元最短路径的算法——Floyd算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前，我们介绍了单源最短路径问题：Dijkstra算法——解决正权边图上的单源最短路径；Bellman-Ford算法——解决图上带负权边的单源最短路径问题。而今天，我们将主要介绍一种解决图上多元最短路径的算法——Floyd算法。</p>
<!-- more -->
<p>本文概要：</p>
<ul>
<li>算法背景</li>
<li>算法思想</li>
<li>算法实例</li>
<li>算法实现</li>
</ul>
<p>P.s：本文图例参考：<a href="https://juejin.im/post/5d8ede95e51d457824771d27">原文链接</a></p>
<h2 id="1-算法背景">1. 算法背景</h2>
<p>现实生活中，我们的需求时常不仅仅是求得某地到其他各地的最短距离，更常见的情况是我们需要知道各地之间的最短距离。一种朴素且可行的想法是：对于图中每个节点使用解决单源最短路径问题的算法（Dijkstra算法 或 Bellman-Ford算法）。然而，在现实环境中图数据规模庞大，该方法的时间复杂度显然是我们所难以接受的。因此，我们需要一种高效的方法解决这样一个多源最短路径问题。</p>
<p>解决多源最短路径问题的众多算法中，最为人们所熟知的是Floyd算法。该算法凭借其明了的思想、简洁的代码实现，被大家称之为一个短小精悍的算法。本文将在后续部分主要介绍该算法的核心思想。</p>
<h2 id="2-算法思想">2. 算法思想</h2>
<p>之前在介绍Dijkstra算法时，我们首次提出了**“松弛”**的思想，并强调这一思想是大多数最短路算法的核心思想。因此，Floyd算法也不例外，其核心思想概括而言是——<strong>动态规划策略+松弛</strong>。<br>
在正式介绍算法之前，我们对下图进行观察：<br>
<img src="https://mocuishle0.github.io//post-images/1590718757078.png" alt="" loading="lazy"><br>
不难发现，在不考虑其他节点/路径的情况下，节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1\to 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>之间的最短距离即为边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span>的权值6。然而，如果我们引入节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，并利用边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,3),(3,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span>可将节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>→</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1\to 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>之间的最短距离更新为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，即松弛成功。<br>
因此，我们不难想到——对图中所有点均进行试探，判断每一个点对间的距离是否因为加入的点而更新，即可得到任意两点间的最短距离。这便是Floyd算法的核心思想。总结如下：<br>
1）利用邻接矩阵dist[i][j]储存节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>间的最短距离。如果没有直接相连的两点那么默认为一个很大的值，并且其到自己的长度为0；<br>
2）从第1个到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span></span></span></span>个点依次加入图中。每个点加入进行试探是否有路径长度被更新；<br>
3）上述试探具体方法为遍历图中每一个点(i,j双重循环)，判断每一个点对距离是否因为加入的点而发生最小距离变化。如果发生改变，那么两点(i,j)距离就更新；<br>
4）重复上述直到最后插点试探完成。</p>
<h2 id="3-算法实例">3. 算法实例</h2>
<p>依然沿用我们上述的图例：<br>
<img src="https://mocuishle0.github.io//post-images/1590720071412.png" alt="" loading="lazy"><br>
利用邻接矩阵dist[i][j]储存节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>间的最短距离，上述dist[i][j]矩阵展示了初始阶段的内容。之后我们对图中每个节点进行试探：</p>
<p>对于节点1进行试探：由于1的加入，使得本来不连通的2，3点对和2，4点对变得联通，并且加入1后距离为当前最小。同时，我们发现加入1其中也使得产生路径3$\to<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>\to<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">但</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">路</mi><mi mathvariant="normal">径</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">4，但是路径3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">路</span><span class="mord cjk_fallback">径</span><span class="mord">3</span></span></span></span>\to<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>\to$4的距离为9远远大于本来的(3,4)为2，所以不进行更新。<br>
<img src="https://mocuishle0.github.io//post-images/1590720145062.png" alt="" loading="lazy"></p>
<p>对于节点2进行试探：<br>
<img src="https://mocuishle0.github.io//post-images/1590720406969.png" alt="" loading="lazy"><br>
后续同理。</p>
<h2 id="4-算法实现">4. 算法实现</h2>
<p>Floyd算法的实现非常简洁，其核心代码仅需要三层循环即可：</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    for(int j = 1; j &lt;= n; j++)
    {
        for(int k = 1; k &lt;= n; k++)
        {
            if(dis[j][k] &gt; dis[j][i] + dis[i][k])
            {
                dis[j][k] = dis[j][i] + dis[i][k];
            }
        }
    }
}
</code></pre>
<p>显然，该算法复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图算法：单源最短路径问题——Bellman-Ford算法]]></title>
        <id>https://mocuishle0.github.io/post/tu-suan-fa-dan-yuan-zui-duan-lu-jing-wen-ti-bellman-ford-suan-fa/</id>
        <link href="https://mocuishle0.github.io/post/tu-suan-fa-dan-yuan-zui-duan-lu-jing-wen-ti-bellman-ford-suan-fa/">
        </link>
        <updated>2020-05-28T09:00:30.000Z</updated>
        <summary type="html"><![CDATA[<p>在前一篇文章中，主要介绍了如何利用Dijkstra算法解决正权图上的单源最短路径问题。然而，在现实生活中的许多图模型中，其权值并不一定全部为正。因此，本文将讨论带负权图上的单源最短路径问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在前一篇文章中，主要介绍了如何利用Dijkstra算法解决正权图上的单源最短路径问题。然而，在现实生活中的许多图模型中，其权值并不一定全部为正。因此，本文将讨论带负权图上的单源最短路径问题。</p>
<!-- more -->
<p>本文概要：</p>
<ul>
<li>算法背景</li>
<li>算法思想</li>
<li>算法实例</li>
<li>算法分析</li>
<li>算法性质</li>
</ul>
<h2 id="1-算法背景dijkstra算法的局限性">1. 算法背景——Dijkstra算法的局限性</h2>
<p>考虑以下实例：<br>
<img src="https://mocuishle0.github.io//post-images/1590657049468.png" alt="" loading="lazy"><br>
根据Dijkstra算法的思想，一旦确定源节点与任意节点最短距离后，在后续的过程中该距离将不会被松弛。然而，由于负权边的存在将与该情况发生冲突，因此Dijkstra算法无法适用于负权图上的单源最短路径问题。</p>
<p>根据上述情况随之需要思考：图中存在负权边时，是否一定存在单源最短路径?——<strong>不一定</strong>。考虑以下情况：<br>
<img src="https://mocuishle0.github.io//post-images/1590657737868.png" alt="" loading="lazy"><br>
所以，<strong>若源点𝒔无可达负环，则存在源点𝒔的单源最短路径</strong>。</p>
<p>综上，我们给出图中允许出现负权边时的单源最短路径问题的定义：<br>
<strong>定义. 单源最短路径问题（可含负权边）：</strong></p>
<ul>
<li>输入：
<ul>
<li>带权图𝑮 =(𝑽, 𝑬, 𝑾 )</li>
<li>源点编号𝒔</li>
</ul>
</li>
<li>输出：
<ul>
<li>源点𝒔到所有其他顶点𝒕的最短距离𝜹(𝒔, 𝒕)和最短路径&lt; 𝒔, … , 𝒕 &gt;</li>
<li>或存在源点𝒔可达的负环</li>
</ul>
</li>
</ul>
<p>根据问题定义可知，该问题存在以下两点挑战：</p>
<ul>
<li>挑战𝟏：图中存在负权边时，如何求解单源最短路径?</li>
<li>挑战𝟐：图中存在负权边时，如何发现源点可达负环?</li>
</ul>
<h2 id="2-算法思想多轮松弛">2. 算法思想——多轮松弛</h2>
<p>在Dijkstra算法中，我们主要通过<strong>松弛操作</strong>迭代更新最短距离：<br>
<img src="https://mocuishle0.github.io//post-images/1590658201059.png" alt="" loading="lazy"><br>
直观地，存在负权边时，需要比Dijkstra算法更多次数的松弛操作：<br>
<img src="https://mocuishle0.github.io//post-images/1590658320213.png" alt="" loading="lazy"></p>
<p><strong>Bellman-Ford算法</strong></p>
<ul>
<li>解决挑战1：图中存在负权边时，如何求解单源最短路径?
<ul>
<li>每轮对<strong>所有边</strong>进行松弛，持续迭代|𝑽 |-1轮</li>
</ul>
</li>
<li>解决挑战2：图中存在负权边时，如何发现源点可达负环?
<ul>
<li>进行第|𝑽 |轮松弛，若仍松弛成功，存在源点𝒔可达的负环</li>
</ul>
</li>
</ul>
<h2 id="3-算法实例">3. 算法实例</h2>
<p>初始时，我们任意给定一个松弛边的顺序：<br>
<img src="https://mocuishle0.github.io//post-images/1590658636753.png" alt="" loading="lazy"><br>
第一轮松弛后，结果如图：<br>
<img src="https://mocuishle0.github.io//post-images/1590658718748.png" alt="" loading="lazy"><br>
第二轮松弛后，结果如图：<br>
<img src="https://mocuishle0.github.io//post-images/1590658764758.png" alt="" loading="lazy"><br>
第三轮松弛后，结果如图：<br>
<img src="https://mocuishle0.github.io//post-images/1590658797977.png" alt="" loading="lazy"><br>
第四轮松弛后，结果如图：<br>
<img src="https://mocuishle0.github.io//post-images/1590658840317.png" alt="" loading="lazy"></p>
<p>可见，第四轮后已经无法继续松弛，因此后续必然无法继续松弛，可得到最终结果。</p>
<h2 id="4-算法分析">4. 算法分析</h2>
<p><img src="https://mocuishle0.github.io//post-images/1590660153675.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590660173506.png" alt="" loading="lazy"><br>
显然，该算法的复杂度为𝑶(|𝑬 | ⋅ |𝑽 |)</p>
<h2 id="5-算法性质正确性证明">5. 算法性质——正确性证明：</h2>
<ul>
<li>挑战𝟏：图中存在负权边时，如何求解单源最短路径?——最坏情况分析<br>
<img src="https://mocuishle0.github.io//post-images/1590660327820.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590660352404.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590660406572.png" alt="" loading="lazy"></li>
<li>挑战𝟐：图中存在负权边时，如何发现源点可达负环?<br>
<img src="https://mocuishle0.github.io//post-images/1590660507814.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590660565463.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590660582971.png" alt="" loading="lazy"></li>
</ul>
<h2 id="6-小结">6. 小结</h2>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1590660611474.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图算法：单源最短路径问题——Dijkstra算法]]></title>
        <id>https://mocuishle0.github.io/post/tu-suan-fa-dan-yuan-zui-duan-lu-jing-wen-ti-dijkstra-suan-fa/</id>
        <link href="https://mocuishle0.github.io/post/tu-suan-fa-dan-yuan-zui-duan-lu-jing-wen-ti-dijkstra-suan-fa/">
        </link>
        <updated>2020-05-28T03:01:54.000Z</updated>
        <summary type="html"><![CDATA[<p>最短路径问题始终是图算法中一类重要的研究问题，目前也有众多工作提出了一些高效的解决策略。然而，就单源最短路径问题而言，Dijkstra算法和Bellman-Ford算法历经多年仍然是最经典的算法。本文将重点介绍Dijkstra算法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最短路径问题始终是图算法中一类重要的研究问题，目前也有众多工作提出了一些高效的解决策略。然而，就单源最短路径问题而言，Dijkstra算法和Bellman-Ford算法历经多年仍然是最经典的算法。本文将重点介绍Dijkstra算法。</p>
<!-- more -->
<p>本文概要：</p>
<ul>
<li>算法背景</li>
<li>算法思想</li>
<li>算法实例</li>
<li>算法实现</li>
<li>算法分析</li>
<li>算法小结</li>
</ul>
<h2 id="1-算法背景">1. 算法背景</h2>
<p>最短路径问题的应用背景极其广泛，例如：查询从某地A到达目的地B的最短路径/时耗，查询社交网络中用户A和用户B之间最短的社交代价等等。其实，以上问题其实质均可建模为一类带权值的图模型。在本文中，我们重点讨论单源最短路径问题，即源节点确定的最短路径查询问题。回想一下，我们之前也说到：BFS搜素也可以解决一些最短路径，此处进行一些解释：<br>
下图所示是一张地铁线路图，如果我们的问题是：需要求从地点A到地点B，如何规划路径可使得地铁<strong>经停最少车站</strong>。<br>
<img src="https://mocuishle0.github.io//post-images/1590636050661.png" alt="" loading="lazy"><br>
我们可以使用BFS算法即可求的相应结果，因为该问题其实可建模为在无权图（或所有边权值均为1的带权图）上的最短路问题。<br>
然而，如果我们的问题是：需要求从地点A到地点B，如何规划路径可使得地铁<strong>运行时间最短</strong>。<br>
<img src="https://mocuishle0.github.io//post-images/1590637196384.png" alt="" loading="lazy"><br>
显然，该问题实质为如何计算带权图中源点到所有其他顶点的最短路径。对于带权图我们无法使用BFS方法直接求解，因此引出我们的Dijkstra算法。<br>
我们首先给出问题的定义：<br>
<strong>定义1.1 单源最短路径问题 (边权为正)：</strong></p>
<ul>
<li>输入：
<ul>
<li>带权图𝑮 =(𝑽, 𝑬, 𝑾 )，其中𝒘(𝒖, 𝒗) ≥ 𝟎（图中所有边权为正）, (𝒖, 𝒗) ∈ 𝑬</li>
<li>源点编号𝒔</li>
</ul>
</li>
<li>输出：源点𝒔到所有其他顶点𝒕的<strong>最短距离</strong>𝜹(𝒔, 𝒕)和<strong>最短路径</strong>&lt; 𝒔, … , 𝒕 &gt;<br>
P.s：需要强调的是，Dijkstra算法所能解决的是边权值权值均为正数的情况。对于权值为负数的情况，该算法并不能很好解决。</li>
</ul>
<h2 id="2-算法思想">2. 算法思想</h2>
<p>Dijkstra算法其算法思想与之前Prim算法求最小生成树有异曲同工之处，但由于其处理问题不同，故存在一定差异。<br>
Dijkstra算法的实现我们同样借助辅助数组来完成：</p>
<ul>
<li>𝒅𝒊𝒔𝒕表示距离上界（估计距离）：
<ul>
<li>源点𝒔，𝒅𝒊𝒔𝒕[𝒔]= 𝟎；其他顶点𝒖，𝒅𝒊𝒔𝒕[𝒖]初始化为∞;</li>
<li>𝒅𝒊𝒔𝒕[𝒖]：源点𝒔到顶点𝒖的距离上界，𝜹(𝒔, 𝒖) ≤ 𝒅𝒊𝒔𝒕 𝒖</li>
</ul>
</li>
<li>𝒄𝒐𝒍𝒐𝒓表示顶点状态：
<ul>
<li>黑色：到顶点𝒖最短路已被确定</li>
<li>白色：到顶点𝒖最短路尚未被确定</li>
</ul>
</li>
<li>𝒑𝒓𝒆𝒅表示前驱顶点：
<ul>
<li>(𝒑𝒓𝒆𝒅[𝒖] , 𝒖)𝒊为最短路径上的边</li>
</ul>
</li>
</ul>
<p>总结算法的核心思想如下：<br>
<img src="https://mocuishle0.github.io//post-images/1590640865461.png" alt="" loading="lazy"><br>
目前存在以下两个问题：</p>
<ul>
<li>选择哪个白色顶点变为黑色——贪心策略选择<br>
<img src="https://mocuishle0.github.io//post-images/1590640991934.png" alt="" loading="lazy"></li>
<li>如何更新每顶点的估计距离——利用已选节点进行松弛处理<br>
<img src="https://mocuishle0.github.io//post-images/1590641045056.png" alt="" loading="lazy"></li>
</ul>
<h2 id="3-算法实例">3. 算法实例</h2>
<p>初始时：<br>
<img src="https://mocuishle0.github.io//post-images/1590641894616.png" alt="" loading="lazy"><br>
利用当前已确定节点松弛其相邻接节点：<br>
<img src="https://mocuishle0.github.io//post-images/1590641944151.png" alt="" loading="lazy"><br>
之后，贪心选择当前估计距离最小的节点：<br>
<img src="https://mocuishle0.github.io//post-images/1590642006599.png" alt="" loading="lazy"><br>
重复上述过程，直至确定源节点到所有节点的最小距离：<br>
<img src="https://mocuishle0.github.io//post-images/1590642154514.png" alt="" loading="lazy"></p>
<h2 id="4-算法实现">4. 算法实现</h2>
<p>通过上述实例演示，其实我们不难发现：Dijkstra算法整个算法流程与Prim算法的实现很类似。以下我们给出Dijkstra算法直观实现的伪代码：<br>
<img src="https://mocuishle0.github.io//post-images/1590650064773.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590650107560.png" alt="" loading="lazy"><br>
以上对于Dijkstra算法朴素地实现，其复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<br>
显然，算法中贪心选择𝒅𝒊𝒔𝒕数组中最小的节点仍然可以借助优先队列实现，以此来降低算法复杂度：<br>
<img src="https://mocuishle0.github.io//post-images/1590650766296.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590650813491.png" alt="" loading="lazy"><br>
可见，通过优先队列实现Dijkstra算法，可将复杂度降至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|E|.log|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="5算法分析">5.算法分析</h2>
<p>童咏昕老师在《算法设计与分析》课程中详细讲解了Dijkstra算法的正确性证明：<br>
<img src="https://mocuishle0.github.io//post-images/1590651213094.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590651261482.png" alt="" loading="lazy"><br>
该证明使用反证法，巧妙地借助了逆否命题与原命题等价证得Dijkstra算法的正确性。反证法也是证明算法正确性时常用的方法之一。</p>
<h2 id="6算法小结">6.算法小结</h2>
<h3 id="61-dijkstra算法-prim算法">6.1 Dijkstra算法 &amp; Prim算法</h3>
<p>Dijkstra算法与Prim算法有很多<strong>相似</strong>之处：</p>
<ul>
<li>均是基于贪心策略的算法；</li>
<li>均使用𝒅𝒊𝒔𝒕数组；</li>
<li>算法过程中，均需要不断更新𝒅𝒊𝒔𝒕数组；</li>
</ul>
<p>但同时，Dijkstra算法与Prim算法由于其处理问题不同，故仍存在差异：</p>
<ul>
<li>虽然均需要使用𝒅𝒊𝒔𝒕数组，但𝒅𝒊𝒔𝒕数组作用不同：
<ul>
<li>Prim算法中，𝒅𝒊𝒔𝒕数组用于记录横跨割的边的权重；</li>
<li>Dijkstra算法中，𝒅𝒊𝒔𝒕数组用于记录距离上界（估计距离）；</li>
<li>P.s：Prim算法需要维护候选轻边权重；Dijkstra算法需要维护源节点到任意节点间路径最短距离。</li>
</ul>
</li>
<li>更新𝒅𝒊𝒔𝒕数组的方法不同：
<ul>
<li>Prim算法将一个节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>选入子树后，判断该节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>到邻居节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的距离是否小于𝒅𝒊𝒔𝒕[v]；</li>
<li>Dijkstra算法确定源节点到一个节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的最短距离后，判断利用源节点到节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的最短路径能否将源节点到节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的邻居节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的距离松弛，即：𝒅𝒊𝒔𝒕[u]+$w(u,v)\leq $𝒅𝒊𝒔𝒕[v]；</li>
</ul>
</li>
</ul>
<h3 id="62-dijkstra算法-bfs算法">6.2 Dijkstra算法 &amp; BFS算法</h3>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1590652128370.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图算法：最小生成树]]></title>
        <id>https://mocuishle0.github.io/post/tu-suan-fa-zui-xiao-sheng-cheng-shu/</id>
        <link href="https://mocuishle0.github.io/post/tu-suan-fa-zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-05-27T03:17:38.000Z</updated>
        <summary type="html"><![CDATA[<p>最小生成树问题是图算法问题中一类经典的问题，其在大量其他的图算法问题中也有广泛的应用。最小生成树问题，其核心是“贪心策略”在图算法中的应用，并由此产生了两类经典的最小生成树算法：<strong>Prim算法</strong>&amp;<strong>Kruskal算法</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最小生成树问题是图算法问题中一类经典的问题，其在大量其他的图算法问题中也有广泛的应用。最小生成树问题，其核心是“贪心策略”在图算法中的应用，并由此产生了两类经典的最小生成树算法：<strong>Prim算法</strong>&amp;<strong>Kruskal算法</strong>。</p>
<!-- more -->
<p>本文内容概要：</p>
<ul>
<li>最小生成树问题背景及通用框架</li>
<li>Prim算法</li>
<li>Kruskal算法</li>
</ul>
<h2 id="1-最小生成树问题背景及通用框架">1. 最小生成树问题背景及通用框架</h2>
<h3 id="11-问题引入">1.1 问题引入：</h3>
<p>实例：城市间道路修建问题——需要修建道路连通城市，各道路花费不同，求解连通各城市的最小花费是多少？<br>
<img src="https://mocuishle0.github.io//post-images/1590550021796.png" alt="" loading="lazy"></p>
<h3 id="12-问题定义">1.2 问题定义：</h3>
<p><strong>定义-1.1 子图（Subgraph）：</strong> 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal">′</mo></msup><mo>⊆</mo><mi>V</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">V&#x27;\subseteq V, E&#x27;\subseteq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.887862em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，则称图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><msup><mi>V</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">G&#x27;=(V&#x27;,E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>的一个子图；<br>
<strong>定义-1.2 生成子图（Spanning Subgraph）：</strong> 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>V</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mi>V</mi><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>⊆</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">V&#x27;= V, E&#x27;\subseteq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，则称图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><msup><mi>V</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">G&#x27;=(V&#x27;,E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>的一个生成子图；<br>
<img src="https://mocuishle0.github.io//post-images/1590550212312.png" alt="" loading="lazy"><br>
<strong>定义-1.3 生成树（Spanning Tree）：</strong> 图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><msup><mi>V</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>E</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">T&#x27;=(V&#x27;,E&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是无向图图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>的一个生成子图，并且是连通、无环的（树）；<br>
<img src="https://mocuishle0.github.io//post-images/1590550375513.png" alt="" loading="lazy"><br>
<strong>P.s：权重最小的生成树可能不唯一！（但如果各条边权重各不相同，则最小生成树唯一）</strong></p>
<p><strong>定义-1.4 最小生成树问题（Minimum Spanning Tree Problem）：</strong></p>
<ul>
<li>输入：连通的无向图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi>W</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E,W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>∈</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">w(u,v)\in W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>表示边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>的权重；</li>
<li>输出：无向图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi>W</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E,W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>的最小生成树<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo>(</mo><msub><mi>V</mi><mi>T</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">T=(V_T,E_T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，<br>
* 优化目标：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><msub><mo>∑</mo><mrow><mi>e</mi><mo>∈</mo><msub><mi>E</mi><mi>T</mi></msub></mrow></msub><mi>w</mi><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">min \sum_{e\in E_T} w(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.150015em;vertical-align:-0.400015em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.4002900000000005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.400015em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><br>
* 约束条件：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi mathvariant="normal">.</mi><mtext> </mtext><msub><mi>V</mi><mi>T</mi></msub><mo>=</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>E</mi><mi>T</mi></msub><mo>⊆</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">s.t. \  V_T=V,E_T\subseteq E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></li>
</ul>
<h3 id="13-通用框架">1.3 通用框架</h3>
<h2 id="需要注意的是由于最小生成树是原图的一个生成子图-因此求解最小生成树其实质是求原图中属于最小生成树的边集"><img src="https://mocuishle0.github.io//post-images/1590550916058.png" alt="" loading="lazy"><br>
需要注意的是，由于最小生成树是原图的一个<strong>生成子图</strong>。因此，求解最小生成树，其实质是求原图中属于最小生成树的边集。</h2>
<p><strong>问题1：如何保证边集𝑨仍是最小生成树的子集？</strong><br>
<strong>定义-1.5 安全边（Safe Edge）：</strong><br>
* 𝑨是某棵最小生成树𝑻边的子集，𝑨 ⊆ 𝑻<br>
* 𝑨 ∪ {(𝒖, 𝒗)} 仍是 𝑻 边的一个子集，则称(𝒖, 𝒗)是𝑨的安全边</p>
<p><strong>回答1：若每次向边集𝑨中新增安全边，可保证边集𝑨是最小生成树的子集。可将框架具体为：</strong><br>
<img src="https://mocuishle0.github.io//post-images/1590551312240.png" alt="" loading="lazy"></p>
<p><strong>问题2：如何有效辨识安全边？</strong><br>
<strong>定义-1.6 割（Cut）：</strong> 图𝑮 =(𝑽, 𝑬)是一个连通无向图，割(𝑺, 𝑽 − 𝑺)将图𝑮的顶点集𝑽划分为两部分。<br>
<img src="https://mocuishle0.github.io//post-images/1590553987173.png" alt="" loading="lazy"><br>
<strong>定义-1.7 横跨（Cross）：</strong> 给定割(𝑺, 𝑽 − 𝑺)和边(𝒖, 𝒗)，𝒖 ∈ 𝑺, 𝒗 ∈ 𝑽 − 𝑺，称边横跨(𝒖, 𝒗)割(𝑺, 𝑽 − 𝑺)<br>
<img src="https://mocuishle0.github.io//post-images/1590554059152.png" alt="" loading="lazy"><br>
<strong>定义-1.8 轻边（Light Edge）：</strong> 横跨割的所有边中，权重最小的称为横跨这个割的一条轻边。<br>
<img src="https://mocuishle0.github.io//post-images/1590554143666.png" alt="" loading="lazy"><br>
<strong>定义-1.9 不妨害（Respect）：</strong> 如果一个边集𝑨中没有边横跨某割，则称该割不妨害边集𝑨。<br>
<img src="https://mocuishle0.github.io//post-images/1590554216822.png" alt="" loading="lazy"></p>
<p><strong>安全边辨识定理：</strong><br>
前提：给定图𝑮 =(𝑽, 𝑬 )是一个带权的连通无向图，令𝑨是边集𝑬的一个子集，且𝑨包含在图𝑮的某棵最小生成树中。<br>
内容：<br>
* 若割(𝑺, 𝑽 − 𝑺)是图𝑮中不妨害边集𝑨的任意割，且(𝒖, 𝒗)是横跨该割的轻边；<br>
* 则对于边集𝑨，边(𝒖, 𝒗)是其安全边。<br>
<img src="https://mocuishle0.github.io//post-images/1590554493870.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590554885982.png" alt="" loading="lazy"></p>
<p>综上所述，我们可将通用框架作如下总结：<br>
<img src="https://mocuishle0.github.io//post-images/1590555008306.png" alt="" loading="lazy"><br>
即：</p>
<ul>
<li>保证无环；</li>
<li>找轻边。</li>
</ul>
<h2 id="2-prim算法">2. Prim算法</h2>
<p>Prim算法是我们以上总结的求解最小生成树通用框架策略的一种具体实现，具体而言该方法主要着眼于“节点”的角度。其思想概括如下：</p>
<ul>
<li>保证无环——始终保持一棵树</li>
<li>找轻边——优先队列求轻边</li>
</ul>
<h3 id="21-算法思想">2.1 算法思想：</h3>
<ul>
<li><strong>步骤1</strong>：选择任意一个<strong>顶点</strong>，作为生成树的起始顶点；</li>
<li><strong>步骤2</strong>：保持边集𝑨始终为一棵树，选择割(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 𝑽 − <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)；</li>
<li><strong>步骤3</strong>：选择横跨割(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 𝑽 − <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的轻边，添加到边集𝑨中；</li>
<li><strong>步骤4</strong>：重复步骤2和步骤3，直至覆盖所有<strong>顶点</strong>。<br>
<img src="https://mocuishle0.github.io//post-images/1590564519809.png" alt="" loading="lazy"></li>
</ul>
<h3 id="22-算法实现">2.2 算法实现：</h3>
<p>为便于算法描述，仍借用辅助数组标记各节点状态以及横跨割的边的权重：</p>
<ul>
<li>𝒄𝒐𝒍𝒐𝒓数组：表示顶点状态
<ul>
<li>Black——节点已覆盖，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>∈</mo><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">u\in 𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>White——节点未覆盖，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>∈</mo><mi>𝑽</mi><mo>−</mo><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">u\in 𝑽-𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>𝒑𝒓𝒆𝒅记录前驱节点：
<ul>
<li>(𝒑𝒓𝒆𝒅[𝒖], 𝒖)即为最小生成树的边</li>
</ul>
</li>
<li>𝒅𝒊𝒔𝒕记录横跨割(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 𝑽 − <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的边的权重：
<ul>
<li>𝒅𝒊𝒔𝒕[u]——顶点集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到顶点𝒖的最短距离，即：𝒅𝒊𝒔𝒕[u]=𝐦𝐢𝐧 {𝒘(𝒙, 𝒖)},∀𝒙∈<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li>
<li><strong>轻边</strong>——𝐦𝐢𝐧{𝒅𝒊𝒔𝒕[𝒖]}, ∀𝒖 ∈ 𝑽−<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑽</mi><mi>𝑨</mi></msub></mrow><annotation encoding="application/x-tex">𝑽_𝑨</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.18625em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.18625em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<img src="https://mocuishle0.github.io//post-images/1590565413627.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="23-算法实例">2.3 算法实例：</h3>
<p>不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>为起始节点：<br>
<img src="https://mocuishle0.github.io//post-images/1590564567231.png" alt="" loading="lazy"><br>
在横跨割的候选边中选轻边，并加入边集中：<br>
<img src="https://mocuishle0.github.io//post-images/1590564751084.png" alt="" loading="lazy"><br>
更新横跨割的候选边：<br>
<img src="https://mocuishle0.github.io//post-images/1590564832618.png" alt="" loading="lazy"><br>
...<br>
最终求得最小生成树：<br>
<img src="https://mocuishle0.github.io//post-images/1590564889219.png" alt="" loading="lazy"></p>
<h3 id="24-算法伪代码">2.4 算法伪代码：</h3>
<p>首先我们给出算法直观地伪代码，如下：<br>
<img src="https://mocuishle0.github.io//post-images/1590565758127.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590565799726.png" alt="" loading="lazy"><br>
可见，直观地实现Prim算法，其复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。然而，我们发现：在找轻边的过程中，我们可以采用<strong>优先队列</strong>这一数据结构简化算法复杂度：<br>
P.s：关于优先队列——通过二叉堆进行实现：<br>
<img src="https://mocuishle0.github.io//post-images/1590566045374.png" alt="" loading="lazy"><br>
改进后伪代码如下：<br>
<img src="https://mocuishle0.github.io//post-images/1590566171186.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590566208236.png" alt="" loading="lazy"><br>
可见，利用优先队列改进后，Prim算法复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|E|.log|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p>
<h3 id="25-小结">2.5 小结：</h3>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1590566349042.png" alt="" loading="lazy"></figure>
<h2 id="3-kruskal算法">3. Kruskal算法：</h2>
<p>Kruskal算法同样是求解最小生成树通用框架策略的一种具体实现。具体而言，该方法主要着眼于“边”的角度。其思想概括如下：</p>
<ul>
<li>保证无环——每次选边判断是否成环</li>
<li>找轻边——每次选当前权重最小边</li>
</ul>
<h3 id="31-算法思想">3.1 算法思想：</h3>
<p>Kruskal算法可以看作是对通用框架的直接实现：</p>
<ul>
<li>保证所选边集𝑨是一个无环图——选边时避免成环，即：每次选边判断是否成环；</li>
<li>保证所选边集𝑨仍然是最小生成树的子集——每次选择当前权重最小边。</li>
</ul>
<h3 id="32-实例演示">3.2 实例演示：</h3>
<p>每次选择未选边中权重最小的边：<br>
<img src="https://mocuishle0.github.io//post-images/1590570865352.png" alt="" loading="lazy"><br>
...<br>
直至此时，仍未成环：<br>
<img src="https://mocuishle0.github.io//post-images/1590571087618.png" alt="" loading="lazy"><br>
P.s：此时形成多棵子树（森林），而非一棵树。<br>
下一时刻，我们发现——加入当前最小权重边会形成环路，故跳过该边：<br>
<img src="https://mocuishle0.github.io//post-images/1590571134762.png" alt="" loading="lazy"><br>
最终，最小生成子树如下：<br>
<img src="https://mocuishle0.github.io//post-images/1590571256718.png" alt="" loading="lazy"></p>
<h3 id="33-算法正确性证明">3.3 算法正确性证明：</h3>
<figure data-type="image" tabindex="2"><img src="https://mocuishle0.github.io//post-images/1590571314586.png" alt="" loading="lazy"></figure>
<h3 id="34-算法伪代码">3.4 算法伪代码：</h3>
<figure data-type="image" tabindex="3"><img src="https://mocuishle0.github.io//post-images/1590571372783.png" alt="" loading="lazy"></figure>
<p>根据以上伪代码，可见：实现Kruskal算法核心在于如何判断加入边的端点是否位于同一棵子树。此处引入一种很重要的数据结构——<strong>并查集</strong>（也被称之为“不相交集合”）：</p>
<h3 id="35-附加并查集">3.5 附加：并查集</h3>
<p>并查集是一种可以高效解决“连通性”问题的数据结构。在网上也看到了各种形象化理解并查集的例子，个人感觉最确切的例子可参考：<a href="https://blog.csdn.net/liujian20150808/article/details/50848646">并查集讲解</a>. 简而言之：对于每个查询的元素，指定一个与其同属一个集合的元素作为其代表，若待查询的两个元素其代表相同，则两个元素属于同一集合。并查集主要需要实现以下功能：</p>
<ul>
<li>Create_Set(𝒙)——初始化，初始时，各元素其代表就是自身：<br>
<img src="https://mocuishle0.github.io//post-images/1590572211534.png" alt="" loading="lazy"></li>
<li>Find_Set(𝒙)——查找根节点（代表）：<br>
<img src="https://mocuishle0.github.io//post-images/1590572296716.png" alt="" loading="lazy"></li>
<li>Union_Set(𝒙)——合并两组元素：<br>
<img src="https://mocuishle0.github.io//post-images/1590572370913.png" alt="" loading="lazy"><br>
以上三项功能其时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h为树的高度。树的高度与顶点规模关系可参考以下证明：<br>
<img src="https://mocuishle0.github.io//post-images/1590572496310.png" alt="" loading="lazy"></li>
</ul>
<h3 id="36-算法具体伪代码">3.6 算法具体伪代码：</h3>
<figure data-type="image" tabindex="4"><img src="https://mocuishle0.github.io//post-images/1590572555623.png" alt="" loading="lazy"></figure>
<h2 id="总结">总结：</h2>
<figure data-type="image" tabindex="5"><img src="https://mocuishle0.github.io//post-images/1590572613480.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图算法：图搜索算法——广度优先搜索（BFS）& 深度优先搜索（DFS）]]></title>
        <id>https://mocuishle0.github.io/post/tu-suan-fa-tu-sou-suo-suan-fa-guang-du-you-xian-sou-suo-bfsand-shen-du-you-xian-sou-suo-dfs/</id>
        <link href="https://mocuishle0.github.io/post/tu-suan-fa-tu-sou-suo-suan-fa-guang-du-you-xian-sou-suo-bfsand-shen-du-you-xian-sou-suo-dfs/">
        </link>
        <updated>2020-05-26T03:34:43.000Z</updated>
        <summary type="html"><![CDATA[<p>本文主要介绍两类最基本的图搜索策略——BFS与DFS。BFS与DFS是一种最基础的，但也是最重要的图算法，其被大量应用在图算法的各个领域，众多高级的图算法，其核心其实仍是这两种最基础的图搜索算法。<br>
本文主要依据北京航空航天大学童咏昕教授《算法设计与分析》课程内容，并结合本人对于图数据的研究课题内容，对图搜索上的两类基础算法进行总结。<br>
P.s：本文主要关注无向图上的BFS与DFS算法，关于有向图的搜索算法会在后续进行讨论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文主要介绍两类最基本的图搜索策略——BFS与DFS。BFS与DFS是一种最基础的，但也是最重要的图算法，其被大量应用在图算法的各个领域，众多高级的图算法，其核心其实仍是这两种最基础的图搜索算法。<br>
本文主要依据北京航空航天大学童咏昕教授《算法设计与分析》课程内容，并结合本人对于图数据的研究课题内容，对图搜索上的两类基础算法进行总结。<br>
P.s：本文主要关注无向图上的BFS与DFS算法，关于有向图的搜索算法会在后续进行讨论。</p>
<!-- more -->
<p>本文内容概要：</p>
<ul>
<li>图搜索应用及背景</li>
<li>广度优先搜索（BFS）</li>
<li>深度优先搜索（DFS）</li>
</ul>
<h2 id="1-图搜索">1. 图搜索</h2>
<p>每当提及图搜索问题，便不得不提及图上的可达性查询问题，即：给定图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span>与查询节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，我们需要回答图上是否存在一条路径使得查询节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>之间可达。可达性查询问题是图查询问题中一类最基本，也是最重要的问题，是大多数查询问题的基础。可达性查询问题在现实生活中也具有大量的应用场景，如：社交网络查询任意用户之间的好友关系查询、任意两地之间道路交通的可达性查询等。<br>
近年来，大量的科研工作已在可达性查询问题上进行了深入且细致的研究，提出了包括链分解、树覆盖、区间标记、2-Hop在内的多种高效的查询方法。此外，其研究对象也从传统的静态图进一步讨论到动态图、时间依赖图以至于演化图流序列等。<br>
然而，无论目前在可达性查询领域有多少先进的查询方法，其最基本的思路均集中在如何构建规模合理的查询索引以提升查询效率。换言之，目前的方法均采用以空间成本换取时间成本的策略。关于可达性查询问题上时空代价的权衡可参见下图：<br>
<img src="https://mocuishle0.github.io//post-images/1590476821378.png" alt="" loading="lazy"><br>
在本文中，我们并不对当前最新进的图搜索方法进行介绍，而是对最基础的两类图搜索算法进行介绍。只有切实掌握了最基础的方法，才能进一步掌握更高效的方法。</p>
<h2 id="2-广度优先搜索bfs">2. 广度优先搜索（BFS）</h2>
<h3 id="21-算法思想">2.1 算法思想：</h3>
<p>童咏昕教授在《算法设计与分析》课程中介绍的思想很形象地诠释了BFS的核心思——水滴落入水面所激起的涟漪会向相邻区域逐渐扩散。如下图所示：<br>
<img src="https://mocuishle0.github.io//post-images/1590476891229.png" alt="" loading="lazy"><br>
这种依次扩散的现象，蕴含了搜索图结构的一种顺序，即：<strong>处理某顶点时，一次性发现所有其相邻顶点</strong>。其实质可以称之为一种“<strong>分层</strong>”搜索的思想。该方法在多处同时“扩散”时，为了维护节点处理顺序需要借助“队列”这常用的数据结构。（p.s：队列的性质为先进先出（First In First Out，FIFO））。<br>
综上所述，BFS的核心思想：<strong>处理某顶点时，一次性发现其所有相邻顶点，未处理顶点加入等待队列</strong>。</p>
<h3 id="22-算法实现">2.2 算法实现：</h3>
<p>BFS算法的实现多种多样，可以根据自己的具体应用需求设计相应实现方法。本文中采用《算法设计与分析》课程中提出的实现方法，该方法更易于理解BFS的核心思想，也有助于后续对BFS的应用。<br>
算法首先需要借助以下三类辅助数组维护相关节点信息：</p>
<ul>
<li>𝒄𝒐𝒍𝒐𝒓数组表示顶点状态：
<ul>
<li>𝑾𝒉𝒊𝒕𝒆：白色顶点——𝒖尚未被发现，发现后直接入队；</li>
<li>𝑩𝒍𝒂𝒄𝒌：黑色顶点——𝒖已被处理，无需再次入队；</li>
<li>𝑮𝒓𝒂𝒚：灰色顶点——𝒖已加入队列，无需再次入队。</li>
</ul>
</li>
<li>𝒑𝒓𝒆𝒅数组：表明顶点uu的前驱节点，即：节点uu由𝒑𝒓𝒆𝒅[u]发现</li>
<li>𝒅𝒊𝒔𝒕数组：顶点uu距离源点的距离。</li>
</ul>
<p><strong>实例演示</strong>：<br>
<img src="https://mocuishle0.github.io//post-images/1590477055845.png" alt="" loading="lazy"><br>
P.s: 需要注意的是，由BFS算法中的𝒑𝒓𝒆𝒅数组可衍生出广度优先树：<br>
<img src="https://mocuishle0.github.io//post-images/1590477101703.png" alt="" loading="lazy"></p>
<h3 id="23-算法伪代码">2.3 算法伪代码：</h3>
<p><img src="https://mocuishle0.github.io//post-images/1590477151160.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590477172715.png" alt="" loading="lazy"></p>
<h3 id="24-算法复杂度分析">2.4 算法复杂度分析：</h3>
<ul>
<li>对于每个顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>，搜索其相邻顶点消耗时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>𝑻</mi><mi>𝒖</mi></msub><mo>=</mo><mi>𝑶</mi><mo>(</mo><mi>𝟏</mi><mo>)</mo><mo>+</mo><mi>𝒅</mi><mi>𝒆</mi><mi>𝒈</mi><mo>(</mo><mi>𝒖</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">𝑻_𝒖= 𝑶(𝟏) + 𝒅𝒆𝒈(𝒖)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.12903em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:-0.12903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.09426em;">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.10861em;">d</span><span class="mord boldsymbol" style="margin-right:0.085em;">e</span><span class="mord boldsymbol" style="margin-right:0.105em;">g</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.09426em;">u</span><span class="mclose">)</span></span></span></span></li>
<li>总运行时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝑻</mi><mo>&lt;</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><msub><mi>𝑻</mi><mi>𝒖</mi></msub></mrow><annotation encoding="application/x-tex">𝑻 &lt; \sum_{u\in V} 𝑻_𝒖</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72521em;vertical-align:-0.0391em;"></span><span class="mord boldsymbol" style="margin-right:0.12903em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.12903em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:-0.12903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.09426em;">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>可推得：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><msub><mi>𝑻</mi><mi>𝒖</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><mi>𝑶</mi><mo>(</mo><mi>𝟏</mi><mo>+</mo><mi>𝒅</mi><mi>𝒆</mi><mi>𝒈</mi><mo>(</mo><mi>𝒖</mi><mo>)</mo><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><mi>𝑶</mi><mo>(</mo><mi>𝟏</mi><mo>)</mo><mo>+</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><mi>𝑶</mi><mo>(</mo><mi>𝒅</mi><mi>𝒆</mi><mi>𝒈</mi><mo>(</mo><mi>𝒖</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>𝑶</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>+</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><mi>𝑶</mi><mo>(</mo><mi>𝒅</mi><mi>𝒆</mi><mi>𝒈</mi><mo>(</mo><mi>𝒖</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{u\in V} 𝑻_𝒖=\sum_{u\in V} 𝑶(𝟏 + 𝒅𝒆𝒈(𝒖))=\sum_{u\in V} 𝑶(𝟏)+\sum_{u\in V} 𝑶(𝒅𝒆𝒈(𝒖))=𝑶(|V|)+\sum_{u\in V} 𝑶(𝒅𝒆𝒈(𝒖))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord boldsymbol" style="margin-right:0.12903em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.161108em;"><span style="top:-2.5500000000000003em;margin-left:-0.12903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord boldsymbol mtight" style="margin-right:0.09426em;">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.10861em;">d</span><span class="mord boldsymbol" style="margin-right:0.085em;">e</span><span class="mord boldsymbol" style="margin-right:0.105em;">g</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.09426em;">u</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord mathbf">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.10861em;">d</span><span class="mord boldsymbol" style="margin-right:0.085em;">e</span><span class="mord boldsymbol" style="margin-right:0.105em;">g</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.09426em;">u</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.10861em;">d</span><span class="mord boldsymbol" style="margin-right:0.085em;">e</span><span class="mord boldsymbol" style="margin-right:0.105em;">g</span><span class="mopen">(</span><span class="mord boldsymbol" style="margin-right:0.09426em;">u</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>由握手定理可知：𝒅𝒆𝒈(G)=2|E|；</li>
</ul>
</li>
<li>综上所述：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝑻</mi><mo>=</mo><mi>𝑶</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">𝑻=𝑶(|V|+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord boldsymbol" style="margin-right:0.12903em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="25-其他应用">2.5 其他应用：</h3>
<p>结合BFS中构建的𝒑𝒓𝒆𝒅数组与𝒅𝒊𝒔𝒕数组，我们可以得到源节点到达其可达节点的最短距离：<br>
<img src="https://mocuishle0.github.io//post-images/1590477448782.png" alt="" loading="lazy"><br>
<strong>该方法使后续最短距离算法的核心与基础</strong></p>
<h2 id="3深度优先搜索dfs">3.深度优先搜索（DFS）</h2>
<h3 id="31-算法思想">3.1 算法思想：</h3>
<p>深度优先搜索其核心是基于一种回溯的思想，即：“一条路走到黑”的搜索策略。详细而言，其算法步骤可分为以下三步：</p>
<ul>
<li>分叉时，任选一条边深入；</li>
<li>无边时，后退一步找新边；</li>
<li>找到边，从新边继续深入。</li>
</ul>
<h3 id="32-算法实现">3.2 算法实现：</h3>
<p>与BFS策略相同，DFS算法的实现也多种多样，此处的实现策略主要为了便于体现算法思想以及后续性质介绍。在具体项目中，需要根据项目需求自行调整实现过程。<br>
与BFS的实现类似，我们同样借助辅助数组来实现DFS算法：<br>
P.s：此处使用多个辅助数组来进行实现，虽然显得较为繁复，但每个数组在后续DFS应用中均有重要作用。</p>
<ul>
<li>𝒄𝒐𝒍𝒐𝒓数组表示顶点状态：
<ul>
<li>𝑾𝒉𝒊𝒕𝒆：白色顶点——𝒖尚未被发现；</li>
<li>𝑩𝒍𝒂𝒄𝒌：黑色顶点——𝒖已被处理；</li>
<li>𝑮𝒓𝒂𝒚：灰色顶点——𝒖正在处理。</li>
</ul>
</li>
<li>𝒑𝒓𝒆𝒅数组：表明顶点u的前驱节点，即：节点u由𝒑𝒓𝒆𝒅[u]发现</li>
<li>𝒅数组：顶点发现时刻（变成灰色的时刻）</li>
<li>𝒇数组：顶点完成时刻（变成黑色的时刻）</li>
</ul>
<h3 id="33-算法伪代码">3.3 算法伪代码：</h3>
<p><img src="https://mocuishle0.github.io//post-images/1590477615170.png" alt="" loading="lazy"><br>
<img src="https://mocuishle0.github.io//post-images/1590477701423.png" alt="" loading="lazy"></p>
<h3 id="34-实例演示">3.4 实例演示：</h3>
<p>我们以1号节点作为源节点执行DFS算法：<br>
<img src="https://mocuishle0.github.io//post-images/1590477750236.png" alt="" loading="lazy"></p>
<h3 id="35-复杂性分析">3.5 复杂性分析：</h3>
<p>值得注意的是，虽然DFS涉及递归调用，但是其子问题个数、子问题规模均难以确定。因此，难以使用主定理法或递归树法进行分析。我们仍对DFS过程中，任意一个顶点v的开销进行分析：<br>
<img src="https://mocuishle0.github.io//post-images/1590477797691.png" alt="" loading="lazy"><br>
结合握手定理，可得总时间复杂度：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝑶</mi><mo>(</mo><msub><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow></msub><mo>(</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi>d</mi><mi>j</mi><mo>[</mo><mi>v</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>𝑶</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mo>+</mo><msub><mo>∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>V</mi></mrow></msub><mo>(</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi>d</mi><mi>j</mi><mo>[</mo><mi>v</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mo>)</mo><mo>=</mo><mi>𝑶</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">𝑶(\sum_{v\in V}(1+|Adj[v]|))=𝑶(|V|)+\sum_{u\in V} (|Adj[v]|)=𝑶(|V|+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord">∣</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord boldsymbol" style="margin-right:0.09062em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span></p>
<h3 id="36-算法性质">3.6 算法性质：</h3>
<p>1）深度优先树：与BFS类似，结合𝒑𝒓𝒆𝒅数组可得到一棵深度优先树。据此，可将图中的边分为树边与非树边。<br>
2）后向边：不是树边，但两顶点在深度优先树中是祖先后代关系。</p>
<blockquote>
<p>在无向图中，非树边一定是后向边；</p>
</blockquote>
<p>3）括号化定理：</p>
<ul>
<li>点v发现时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>和结束时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>构成区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(d[v],f[v])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>；</li>
<li>任意两点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v,w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>必然满足以下情况之一：</li>
<li>$(d[v],f[v])\subseteq (d[w],f[w])\to $→ w是v的后代；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>)</mo><mo>∩</mo><mo>(</mo><mi>d</mi><mo>[</mo><mi>w</mi><mo>]</mo><mo separator="true">,</mo><mi>f</mi><mo>[</mo><mi>w</mi><mo>]</mo><mo>)</mo><mo>=</mo><mi mathvariant="normal">∅</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">(d[v],f[v])\cap (d[w],f[w])=\emptyset\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span></span></span></span>→ v和w均不是对方后代<br>
P.s：括号化定理是基于区间标记解决可达性查询的核心思想。<br>
4）白色路径定理：<br>
在深度优先树中，顶点v是w的祖先⇔在v被发现前，从v到w存在全为白色顶点构成的路径。<br>
<img src="https://mocuishle0.github.io//post-images/1590478025331.png" alt="" loading="lazy"></li>
</ul>
<h2 id="4-有向图-无向图-对比">4. 有向图 &amp; 无向图 对比:</h2>
<p>在之前的部分，我们主要以无向图作为研究对象，而在该节我们将对有向图展开讨论。需要注意的是，无向图其实质可以认为是一种边具有双向连通性的特殊的有向图。因此，我们在本节仅讨论有向图与无向图在DFS中性质的一些差异，BFS中的差异可类比得到。</p>
<h3 id="41-连通无向图的优先树与连通有向图的优先森林">4.1 连通无向图的优先树与连通有向图的优先森林:</h3>
<figure data-type="image" tabindex="1"><img src="https://mocuishle0.github.io//post-images/1590478105052.png" alt="" loading="lazy"></figure>
<h3 id="42-深度优先搜索边的分类">4.2 深度优先搜索边的分类:</h3>
<figure data-type="image" tabindex="2"><img src="https://mocuishle0.github.io//post-images/1590478140887.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>